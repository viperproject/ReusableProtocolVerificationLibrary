package attackerstrength

import att "github.com/ModularVerification/ReusableVerificationLibrary/attacker"
import ll "github.com/ModularVerification/ReusableVerificationLibrary/labeledlibrary"
import lib "github.com/ModularVerification/ReusableVerificationLibrary/labeledlibrary/library"
import tm "github.com/ModularVerification/ReusableVerificationLibrary/term"


/**
 * This file shows that the attacker can use the same functionality from the 
 * labeledlibrary, i.e. the attacker can invoke all library functions with
 * bytes known to him (i.e. public/derivable bytes) and will get back bytes
 * (e.g. the ciphertext in the case of encrypt) that are also derivable.
 * This shows that `IsPublishable(t, term)` is a valid invariant for every
 * `term` in the the attacker knowledge, i.e. all terms the attacker can
 * derive satisfy this invariant.
 */

ghost
requires l.Mem()
requires att.attackerKnows(l.Snapshot(), pk)
requires att.attackerKnows(l.Snapshot(), plaintext)
ensures  l.Mem()
ensures  err == nil ==> att.attackerKnows(l.Snapshot(), ciphertext)
func pkeEnc(l *ll.LabeledLibrary, pk, senderPrivateKey, plaintext tm.Term) (ciphertext tm.Term, err error) {
    pkBytes := lib.NewByteStringWithContent(tm.gamma(pk))
    plaintextBytes := lib.NewByteStringWithContent(tm.gamma(plaintext))
    l.AttackerOnlyKnowsPublishableValues(pk)
    l.AttackerOnlyKnowsPublishableValues(plaintext)
    _, err = l.Enc(plaintextBytes, pkBytes, plaintext, pk)
    if err == nil {
        ciphertext = tm.encrypt(plaintext, pk)
        l.Publish(ciphertext)
    }
}
