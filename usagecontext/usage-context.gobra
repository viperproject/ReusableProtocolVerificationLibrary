package usagecontext

import tm "github.com/ModularVerification/ReusableVerificationLibrary/term"
import tr "github.com/ModularVerification/ReusableVerificationLibrary/trace"
import u "github.com/ModularVerification/ReusableVerificationLibrary/usage"


type UsageOption = option[u.Usage]

type UsageContext interface {
    ghost
    pure GetUsage(t tm.Term) UsageOption

    ghost
    pure PkePred(t tr.TraceEntry, usageString string, plaintext, pk tm.Term) bool

    ghost
    requires t1.isSuffix(t2)
    requires PkePred(t1, usageString, plaintext, pk)
    ensures  PkePred(t2, usageString, plaintext, pk)
    PkePredMonotonic(t1, t2 tr.TraceEntry, usageString string, plaintext, pk tm.Term)

    ghost
    pure AeadPred(t tr.TraceEntry, usageString string, key, nonce, plaintext, authtext tm.Term) bool

    ghost
    requires t1.isSuffix(t2)
    requires AeadPred(t1, usageString, key, nonce, plaintext, authtext)
    ensures  AeadPred(t2, usageString, key, nonce, plaintext, authtext)
    AeadPredMonotonic(t1, t2 tr.TraceEntry, usageString string, key, nonce, plaintext, authtext tm.Term)
}

// ghost
// pure func GetUsage(ctx UsageContext, t tm.Term) option[u.Usage] {
//     return t.IsRandom() ? some(tm.getRandomUsage(t)) :
//         (t.IsKdf() && HasKdfUsage(ctx, tm.getInput(t))) ? ctx.KdfUsage(t, u.GetUsageString(get(GetUsage(ctx, tm.getInput(t))))) :
//         t.IsTuple2() ? ctx.Tuple2Usage(t) :
//         // TODO add other usages e.g. for DH or key expansion
//         none[u.Usage]
// }

// ghost
// /** input is the term that is used as key argument to a KDF function */
// pure func HasKdfUsage(ctx UsageContext, t tm.Term) bool {
//     return GetUsage(ctx, t) != none[u.Usage] &&
//         get(GetUsage(ctx, t)).IsKdfKey()
// }
