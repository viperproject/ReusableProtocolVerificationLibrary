package nsl-responder

import ev "gitlab.inf.ethz.ch/arquintl/prototrace/event"
import ll "gitlab.inf.ethz.ch/arquintl/prototrace/labeled-library"
import "gitlab.inf.ethz.ch/arquintl/prototrace/labeling"
import . "gitlab.inf.ethz.ch/arquintl/prototrace/nsl-shared"
import p "gitlab.inf.ethz.ch/arquintl/prototrace/principal"
import tm "gitlab.inf.ethz.ch/arquintl/prototrace/term"
import tr "gitlab.inf.ethz.ch/arquintl/prototrace/trace"


ghost
requires b.Mem(naT, nbT) && b.Version(naT, nbT) == 2
ensures  b.Mem(naT, nbT) && b.Version(naT, nbT) == 3
func (b *B) proveSecurityProperties(naT, nbT tm.Term) {
	// we show that the authentication properties' precondition is satisfied:
	unfold b.Mem(naT, nbT)
	responderInjectiveAgreement(b.llib, b.idA, b.idB, naT, nbT)
	
	// we show now that the same naT & nbT are also secret:
	b.llib.SecrecyLemma(naT, set[p.Id]{ p.principalId(b.idA), p.principalId(b.idB) })
	b.llib.SecrecyLemma(nbT, set[p.Id]{ p.principalId(b.idA), p.principalId(b.idB) })

	b.version = 3
	fold b.Mem(naT, nbT)
}

ghost
decreases
requires l.Mem()
requires l.Ctx() == GetNslContext()
requires (l.Snapshot()).eventOccurs(idB, ev.NewEvent(FinishR, FinishRParams{ idA, idB, naT, nbT }))
ensures  l.Mem()
ensures  l.ImmutableState() == old(l.ImmutableState())
ensures  l.Snapshot() == old(l.Snapshot())
ensures  l.NonInjectiveAgreement(idB, idA, ev.NewEvent(FinishR, FinishRParams{ idA, idB, naT, nbT }), ev.NewEvent(FinishI, FinishIParams{ idA, idB, naT, nbT }), set[p.Id]{ p.principalId(idA), p.principalId(idB) })
// the following postcondition provides further insights about the returned witness:
ensures  optCorruptedId != none[p.Id] ==>
	labeling.containsCorruptId((l.Snapshot()).getCorruptIds(), set[p.Id]{ p.principalId(idA), p.principalId(idB) }) &&
	(get(optCorruptedId).getPrincipal() == idA || get(optCorruptedId).getPrincipal() == idB)
func responderNonInjectiveAgreement(l *ll.LabeledLibrary, idA, idB p.Principal, naT, nbT tm.Term) (optCorruptedId option[p.Id]) {
	prev := l.EventOccursImpliesEventInv(idB, ev.NewEvent(FinishR, FinishRParams{ idA, idB, naT, nbT }))
	prevPrev := tr.getPrev(prev)
	prevPrev.isSuffixTransitive(prev, l.Snapshot())
	prevPrev.getCorruptIdsMonotonic(l.Snapshot())
	if p.principalId(idA) in prevPrev.getCorruptIds() {
		optCorruptedId = some(p.principalId(idA))
	} else if p.principalId(idB) in prevPrev.getCorruptIds() {
		optCorruptedId = some(p.principalId(idB))
	} else {
		optCorruptedId = none[p.Id]
		// Note that we know that neither idA nor idB have been corrupted at timepoint `prevPrev`.
		// However, they might have been corrupted in the meantime and thus we can not make a statement
		// on their current corruption state.
		prevPrev.eventOccursMonotonic(l.Snapshot(), idA, ev.NewEvent(FinishI, FinishIParams{ idA, idB, naT, nbT }))
	}
}

ghost
decreases
requires l.Mem()
requires l.Ctx() == GetNslContext()
requires (l.Snapshot()).eventOccurs(idB, ev.NewEvent(FinishR, FinishRParams{ idA, idB, naT, nbT }))
ensures  l.Mem()
ensures  l.ImmutableState() == old(l.ImmutableState())
ensures  l.Snapshot() == old(l.Snapshot())
ensures  l.InjectiveAgreement(idB, idA, ev.NewEvent(FinishR, FinishRParams{ idA, idB, naT, nbT }), ev.NewEvent(FinishI, FinishIParams{ idA, idB, naT, nbT }), set[p.Id]{ p.principalId(idA), p.principalId(idB) })
// the following postcondition provides further insights about the returned witness:
ensures  optCorruptedId != none[p.Id] ==>
	labeling.containsCorruptId((l.Snapshot()).getCorruptIds(), set[p.Id]{ p.principalId(idA), p.principalId(idB) }) &&
	(get(optCorruptedId).getPrincipal() == idA || get(optCorruptedId).getPrincipal() == idB)
func responderInjectiveAgreement(l *ll.LabeledLibrary, idA, idB p.Principal, naT, nbT tm.Term) (optCorruptedId option[p.Id]) {
	optCorruptedId = responderNonInjectiveAgreement(l, idA, idB, naT, nbT)
	if optCorruptedId == none[p.Id] {
		event := ev.NewEvent(FinishR, FinishRParams{ idA, idB, naT, nbT })
		l.UniqueEventIsUnique(idB, event)
		assert l.EventIsUnique(idB, event)
	}
}
