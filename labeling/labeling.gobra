package labeling

import arb "github.com/ModularVerification/ReusableVerificationLibrary/arbitrary"
import ev "github.com/ModularVerification/ReusableVerificationLibrary/event"
import "github.com/ModularVerification/ReusableVerificationLibrary/label"
import . "github.com/ModularVerification/ReusableVerificationLibrary/principal"
import tm "github.com/ModularVerification/ReusableVerificationLibrary/term"
import tr "github.com/ModularVerification/ReusableVerificationLibrary/trace"
import u "github.com/ModularVerification/ReusableVerificationLibrary/usage"
import . "github.com/ModularVerification/ReusableVerificationLibrary/usagecontext"


/** alias */
type IdSet = set[Id]

/** interface to collect all lemmas for convenience */
type CanFlowLemmas_DYStar interface {
    ghost
    pure canFlowInternal_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel) bool

    ghost
    ensures  canFlowInternal_DYStar(corruptIds, l, l)
    canFlowInternalReflexive_DYStar(corruptIds IdSet, l label.SecrecyLabel)

    ghost
    ensures (canFlowInternal_DYStar(corruptIds, l1, l2) && canFlowInternal_DYStar(corruptIds, l2, l3)) ==> canFlowInternal_DYStar(corruptIds, l1, l3)
    canFlowInternalTransitive_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)

    ghost
    ensures  canFlowInternal_DYStar(corruptIds, l1, label.Public()) ==> canFlowInternal_DYStar(corruptIds, l1, l2)
    flowsToPublicCanFlowInternal_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel)

    ghost
    ensures  (canFlowInternal_DYStar(corruptIds, l2, label.Public()) && canFlowInternal_DYStar(corruptIds, l1, l2)) ==> canFlowInternal_DYStar(corruptIds, l1, label.Public())
    canFlowFlowsToPublic_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel)

    ghost
    requires l1.IsReaders() && l2.IsReaders()
    requires label.GetReaders(l2) subset label.GetReaders(l1)
    ensures canFlowInternal_DYStar(corruptIds, l1, l2)
    canFlowInternalToSubsetReaders_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel)

    ghost
    requires canFlowInternal_DYStar(corruptIds, l1, l3)
    requires canFlowInternal_DYStar(corruptIds, l2, l3)
    ensures  canFlowInternal_DYStar(corruptIds, label.Meet(l1, l2), l3)
    canFlowInternalCreateMeetLhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)

    ghost
    requires canFlowInternal_DYStar(corruptIds, label.Meet(l1, l2), l3)
    ensures  canFlowInternal_DYStar(corruptIds, l1, l3)
    ensures  canFlowInternal_DYStar(corruptIds, l2, l3)
    canFlowInternalResolveMeetLhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)

    ghost
    requires canFlowInternal_DYStar(corruptIds, l1, l2) || canFlowInternal_DYStar(corruptIds, l1, l3)
    ensures  canFlowInternal_DYStar(corruptIds, l1, label.Meet(l2, l3))
    canFlowInternalCreateMeetRhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)

    ghost
    requires canFlowInternal_DYStar(corruptIds, l1, label.Meet(l2, l3))
    requires canFlowInternal_DYStar(corruptIds, l2, l3)
    ensures  canFlowInternal_DYStar(corruptIds, l1, l3)
    canFlowInternalResolveMeetRhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)

    ghost
    requires canFlowInternal_DYStar(corruptIds, l1, l3) || canFlowInternal_DYStar(corruptIds, l2, l3)
    ensures  canFlowInternal_DYStar(corruptIds, label.Join(l1, l2), l3)
    canFlowInternalCreateJoinLhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)

    ghost
    requires canFlowInternal_DYStar(corruptIds, label.Join(l1, l1), l2)
    ensures  canFlowInternal_DYStar(corruptIds, l1, l2)
    canFlowInternalResolveJoinLhs_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel)

    ghost
    requires canFlowInternal_DYStar(corruptIds, l1, l2)
    requires canFlowInternal_DYStar(corruptIds, l1, l3)
    ensures  canFlowInternal_DYStar(corruptIds, l1, label.Join(l2, l3))
    canFlowInternalCreateJoinRhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)

    ghost
    requires canFlowInternal_DYStar(corruptIds, l1, label.Join(l2, l3))
    ensures  canFlowInternal_DYStar(corruptIds, l1, l2)
    ensures  canFlowInternal_DYStar(corruptIds, l1, l3)
    canFlowInternalResolveJoinRhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)

    ghost
    requires canFlowInternal_DYStar(corruptIds, l1, label.Meet(l2, l3))
    requires  l2FlowsToPublic ==> canFlowInternal_DYStar(corruptIds, l2, label.Public())
    requires !l2FlowsToPublic ==> canFlowInternal_DYStar(corruptIds, l3, label.Public())
    ensures   l2FlowsToPublic ==> canFlowInternal_DYStar(corruptIds, l1, l3)
    ensures  !l2FlowsToPublic ==> canFlowInternal_DYStar(corruptIds, l1, l2)
    canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel, l2FlowsToPublic bool)

    ghost
    requires canFlowInternal_DYStar(corruptIds, l1, l2)
    requires canFlowInternal_DYStar(corruptIds, l3, l4)
    ensures  canFlowInternal_DYStar(corruptIds, label.Meet(l1, l3), label.Meet(l2, l4))
    canFlowInternalCreateMeetBoth_DYStar(corruptIds IdSet, l1, l2, l3, l4 label.SecrecyLabel)

    ghost
    requires canFlowInternal_DYStar(corruptIds, l1, l2)
    requires canFlowInternal_DYStar(corruptIds, l3, l4)
    ensures  canFlowInternal_DYStar(corruptIds, label.Join(l1, l3), label.Join(l2, l4))
    canFlowInternalCreateJoinBoth_DYStar(corruptIds IdSet, l1, l2, l3, l4 label.SecrecyLabel)
}

type DefaultLabelingContext struct {
    usage UsageContext
}
DefaultLabelingContext implements tr.LabelingContext
DefaultLabelingContext implements CanFlowLemmas_DYStar

pred (ctx DefaultLabelingContext) Pred() {
    ctx.usage != nil
}

// TODO make ghost
pure func GetDefaultLabelingContext(usage UsageContext) (res DefaultLabelingContext) {
    return DefaultLabelingContext{ usage }
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) IsValid(t tr.TraceEntry, term tm.Term) bool {
    return (term.IsInteger64() ==> true) &&
        (term.IsInteger32() ==> true) &&
        (term.IsConst1() ==> true) &&
        (term.IsString() ==> true) &&
        (term.IsZeroString() ==> true) &&
        (term.IsInfo() ==> true) &&
        (term.IsPrologue() ==> true) &&
        (term.IsGenerator() ==> true) &&
        (term.IsPk() ==> ctx.IsValid(t, tm.getSk(term))) &&
        (term.IsEncrypt() ==>
            ctx.IsValidEncrypt(t, tm.getPk(term), tm.getPlaintext(term), ctx.GetLabel(tm.getPlaintext(term)))) &&
        (term.IsAead() ==>
            ctx.IsValidAead(t, tm.getAeadKey(term), tm.getAeadNonce(term), tm.getPlaintext(term), ctx.GetLabel(tm.getPlaintext(term)), tm.getAuthtext(term))) &&
        (term.IsRandom() ==>
            // `nonceOccurs` saves us from writing yet another function to simply state that `term` is on the trace
            t.OnlyNonceOccurs(term)) &&
        (term.IsExp() ==> exists base, e tm.Term :: { tm.exp(base, e) } term == tm.exp(base, e) && ctx.IsValid(t, base) && ctx.IsValid(t, e)) &&
        ((term.IsHash() || term.IsKdf1() || term.IsKdf2() || term.IsKdf3()) ==> ctx.IsValid(t, tm.getInput(term))) &&
        (term.IsTuple() ==> forall i int :: { tm.getTupleElem(term, i) } 0 <= i && i < term.GetTupleArity() ==> ctx.IsValid(t, tm.getTupleElem(term, i)))
}

ghost
requires acc(ctx.Pred(), _)
requires ctx.GetLabel(plaintext) == plaintextLabel
pure func (ctx DefaultLabelingContext) IsValidEncrypt(t tr.TraceEntry, pk, plaintext tm.Term, plaintextLabel label.SecrecyLabel) bool {
    return ctx.IsValid(t, pk) &&
        ctx.IsValid(t, plaintext) &&
        // message has to flow to secrecy label of secret key
        ctx.CanFlow(t, plaintextLabel, ctx.GetSkLabel(pk)) &&
        (
            // either the plaintext is public ...
            ctx.CanFlow(t, plaintextLabel, label.Public()) ||
            // ... or pkePred holds
            (
                pk.IsPk() &&
                ctx.IsPkeKey(tm.getSk(pk)) &&
                unfolding acc(ctx.Pred(), _) in
                    ctx.usage.PkePred(t, u.GetUsageString(get(ctx.GetUsage(tm.getSk(pk)))), plaintext, pk)))
}

ghost
requires acc(ctx.Pred(), _)
requires ctx.GetLabel(plaintext) == plaintextLabel
pure func (ctx DefaultLabelingContext) IsValidAead(t tr.TraceEntry, key, nonce, plaintext tm.Term, plaintextLabel label.SecrecyLabel, authtext tm.Term) bool {
    return ctx.IsValid(t, key) &&
        ctx.IsValid(t, nonce) &&
        ctx.IsValid(t, plaintext) &&
        ctx.IsValid(t, authtext) &&
        // nonce and authtext have to flow to public
        ctx.CanFlow(t, ctx.GetLabel(nonce), label.Public()) &&
        ctx.CanFlow(t, ctx.GetLabel(authtext), label.Public()) &&
        (
            // either key and message are public...
            (ctx.CanFlow(t, ctx.GetLabel(key), label.Public()) &&
                ctx.CanFlow(t, plaintextLabel, label.Public())) ||
            // ... or message can flow to key's label and AeadPred holds
            (ctx.CanFlow(t, plaintextLabel, ctx.GetLabel(key)) &&
                ctx.HasAeadKeyUsage(key) &&
                unfolding acc(ctx.Pred(), _) in
                    ctx.usage.AeadPred(t, u.GetUsageString(get(ctx.GetUsage(key))), key, nonce, plaintext, authtext)))
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) IsAeadKey(t tr.TraceEntry, key tm.Term, keyL label.SecrecyLabel, usageString string) bool {
    return ctx.IsSecretRelaxed(t, key, keyL, u.AeadKey(usageString))
}

ghost
decreases _ // TODO decreases because we apply an term ADT constructor in each recursive call
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsValid(t1, term)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsValid(t2, term)
func (ctx DefaultLabelingContext) IsValidMonotonic(t1, t2 tr.TraceEntry, term tm.Term, p perm) {
    if (term.IsRandom()) {
        t1.OnlyNonceOccursMonotonic(t2, term)
    } else if (term.IsPk()) {
        ctx.IsValidMonotonic(t1, t2, tm.getSk(term), p / 2)
    } else if (term.IsEncrypt()) {
        pk := tm.getPk(term)
        plaintext := tm.getPlaintext(term)
        ctx.IsValidEncryptMonotonic(t1, t2, pk, plaintext, ctx.GetLabel(plaintext), p / 2)
    } else if term.IsAead() {
        key := tm.getAeadKey(term)
        nonce := tm.getAeadNonce(term)
        plaintext := tm.getPlaintext(term)
        authtext := tm.getAuthtext(term)
        ctx.IsValidAeadMonotonic(t1, t2, key, nonce, plaintext, ctx.GetLabel(plaintext), authtext, p / 2)
    } else if term.IsExp() {
        assert exists base, e tm.Term :: { tm.exp(base, e) } term == tm.exp(base, e) && ctx.IsValid(t1, base) && ctx.IsValid(t1, e)
        base, e := arb.GetArbTerm(), arb.GetArbTerm()
        assume term == tm.exp(base, e) && ctx.IsValid(t1, base) && ctx.IsValid(t1, e)
        ctx.IsValidMonotonic(t1, t2, base, p / 2)
        ctx.IsValidMonotonic(t1, t2, e, p / 2)
    } else if (term.IsHash() || term.IsKdf1() || term.IsKdf2() || term.IsKdf3()) {
        ctx.IsValidMonotonic(t1, t2, tm.getInput(term), p / 2)
    } else if term.IsTuple() {
        invariant 0 <= i && i <= term.GetTupleArity()
        invariant acc(ctx.Pred(), p / 2)
        invariant forall j int :: { tm.getTupleElem(term, j) } 0 <= j && j < term.GetTupleArity() ==> ctx.IsValid(t1, tm.getTupleElem(term, j))
        invariant forall j int :: { tm.getTupleElem(term, j) } 0 <= j && j < i ==> ctx.IsValid(t2, tm.getTupleElem(term, j))
        for i := 0; i < term.GetTupleArity(); i++ {
            ctx.IsValidMonotonic(t1, t2, tm.getTupleElem(term, i), p / 2)
        }
    }
}

ghost
decreases _ // TODO decreases because we apply an term ADT constructor in each recursive call
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.GetLabel(plaintext) == plaintextLabel
requires ctx.IsValidEncrypt(t1, pk, plaintext, plaintextLabel)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsValidEncrypt(t2, pk, plaintext, plaintextLabel)
func (ctx DefaultLabelingContext) IsValidEncryptMonotonic(t1, t2 tr.TraceEntry, pk, plaintext tm.Term, plaintextLabel label.SecrecyLabel, p perm) {
    ctx.IsValidMonotonic(t1, t2, pk, p / 2)
    ctx.IsValidMonotonic(t1, t2, plaintext, p / 2)
    skLabel := ctx.GetSkLabel(pk)
    ctx.CanFlowMonotonic(t1, t2, plaintextLabel, skLabel)
    if (ctx.CanFlow(t1, plaintextLabel, label.Public())) {
        ctx.CanFlowMonotonic(t1, t2, plaintextLabel, label.Public())
    } else {
        unfold acc(ctx.Pred(), p / 2)
        ctx.usage.PkePredMonotonic(t1, t2, u.GetUsageString(get(ctx.GetUsage(tm.getSk(pk)))), plaintext, pk)
        fold acc(ctx.Pred(), p / 2)
    }
}

ghost
decreases _ // TODO decreases because we apply an term ADT constructor in each recursive call
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.GetLabel(plaintext) == plaintextLabel
requires ctx.IsValidAead(t1, key, nonce, plaintext, plaintextLabel, authtext)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsValidAead(t2, key, nonce, plaintext, plaintextLabel, authtext)
func (ctx DefaultLabelingContext) IsValidAeadMonotonic(t1, t2 tr.TraceEntry, key, nonce, plaintext tm.Term, plaintextLabel label.SecrecyLabel, authtext tm.Term, p perm) {
    ctx.IsValidMonotonic(t1, t2, key, p / 2)
    ctx.IsValidMonotonic(t1, t2, nonce, p / 2)
    ctx.IsValidMonotonic(t1, t2, plaintext, p / 2)
    ctx.IsValidMonotonic(t1, t2, authtext, p / 2)
    ctx.CanFlowMonotonic(t1, t2, ctx.GetLabel(nonce), label.Public())
    ctx.CanFlowMonotonic(t1, t2, ctx.GetLabel(authtext), label.Public())
    if (ctx.CanFlow(t1, ctx.GetLabel(key), label.Public()) &&
        ctx.CanFlow(t1, plaintextLabel, label.Public())) {
        ctx.CanFlowMonotonic(t1, t2, ctx.GetLabel(key), label.Public())
        ctx.CanFlowMonotonic(t1, t2, plaintextLabel, label.Public())
    } else {
        ctx.CanFlowMonotonic(t1, t2, plaintextLabel, ctx.GetLabel(key))
        usageCtx := ctx.GetUsage(key)
        unfold acc(ctx.Pred(), p / 2)
        ctx.usage.AeadPredMonotonic(t1, t2, u.GetUsageString(get(usageCtx)), key, nonce, plaintext, authtext)
        fold acc(ctx.Pred(), p / 2)
    }
}

ghost
requires acc(ctx.Pred(), _)
/** expresses that a term is valid and that its label is `l` */
pure func (ctx DefaultLabelingContext) IsLabeled(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) bool {
    return ctx.IsValid(t, term) &&
        ctx.GetLabel(term) == l
}

ghost
requires acc(ctx.Pred(), _)
/** expresses that a term is valid and that `l` flows to its label */
pure func (ctx DefaultLabelingContext) IsLabeledRelaxed(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) bool {
    return ctx.IsValid(t, term) &&
        ctx.CanFlow(t, l, ctx.GetLabel(term))
}

ghost
requires acc(ctx.Pred(), _)
/** expresses that a term is valid and that `l` flows to its label and back */
pure func (ctx DefaultLabelingContext) IsLabeledPrecise(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) bool {
    return ctx.IsValid(t, term) &&
        ctx.CanFlow(t, l, ctx.GetLabel(term)) &&
        ctx.CanFlow(t, ctx.GetLabel(term), l)
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsLabeled(t1, term, l)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsLabeled(t2, term, l)
func (ctx DefaultLabelingContext) IsLabeledMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel, p perm) {
    ctx.IsValidMonotonic(t1, t2, term, p)
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsLabeledRelaxed(t1, term, l)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsLabeledRelaxed(t2, term, l)
func (ctx DefaultLabelingContext) IsLabeledRelaxedMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel, p perm) {
    ctx.IsValidMonotonic(t1, t2, term, p)
    ctx.CanFlowMonotonic(t1, t2, l, ctx.GetLabel(term))
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsLabeledPrecise(t1, term, l)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsLabeledPrecise(t2, term, l)
func (ctx DefaultLabelingContext) IsLabeledPreciseMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel, p perm) {
    ctx.IsValidMonotonic(t1, t2, term, p)
    ctx.CanFlowMonotonic(t1, t2, l, ctx.GetLabel(term))
    ctx.CanFlowMonotonic(t1, t2, ctx.GetLabel(term), l)
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) IsSecret(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage) bool {
    return ctx.IsLabeled(t, term, l) &&
        ctx.GetUsage(term) == some(usage)
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) IsSecretRelaxed(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage) bool {
    return ctx.IsLabeledRelaxed(t, term, l) &&
        ctx.GetUsage(term) == some(usage)
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) IsSecretPrecise(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage) bool {
    return ctx.IsLabeledPrecise(t, term, l) &&
        ctx.GetUsage(term) == some(usage)
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsSecret(t1, term, l, usage)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsSecret(t2, term, l, usage)
func (ctx DefaultLabelingContext) IsSecretMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage, p perm) {
    ctx.IsLabeledMonotonic(t1, t2, term, l, p)
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsSecretRelaxed(t1, term, l, usage)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsSecretRelaxed(t2, term, l, usage)
func (ctx DefaultLabelingContext) IsSecretRelaxedMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage, p perm) {
    ctx.IsLabeledRelaxedMonotonic(t1, t2, term, l, p)
}

ghost
decreases _ // TODO over ADT structure of SecrecyLabel
// we do not take any permission to `ctx.Pred()` since `GetLabel` does not depend on the UsageContext
ensures term.IsInteger64() ==> res == label.Public()
ensures term.IsInteger32() ==> res == label.Public()
ensures term.IsConst1() ==> res == label.Public()
ensures term.IsString() ==> res == label.Public()
ensures term.IsZeroString() ==> res == label.Public()
ensures term.IsInfo() ==> res == label.Public()
ensures term.IsPrologue() ==> res == label.Public()
ensures term.IsGenerator() ==> res == label.Public()
ensures term.IsPk() ==> res == label.Public()
ensures term.IsEncrypt() ==> res == label.Public()
ensures term.IsAead() ==> res == label.Public()
ensures term.IsRandom() ==> res == tm.getRandomLabel(term)
// hash, kdf1, kdf2, and kdf3 are considered one-way functions
// hashes are considered to be fine for sending them to the network
// the result of applying a KDF function however is used as a key and therefore, we want to have the
// tightest label that is possible, which is simply the label of its parameter.
// any more generic label (e.g. even public()) would still be sound but we weaken any secrecy property
// as we would consider an unnecessarily big set of participants of which any could be corrupted and
// thus the secrecy lemma holds trivially
ensures term.IsHash() ==> res == label.Public()
ensures (term.IsKdf1() || term.IsKdf2() || term.IsKdf3()) ==> res == ctx.GetLabel(tm.getInput(term))
ensures term.IsTuple() ==> res == ctx.nestedMeet(getTupleSeq(term), 0) // intersection of audience is allowed to read
// DH exponentiation is special cased:
// if a term is `(g^x)^y` or equivalently `g^(x*y)` it results in the join label of x and y
// i.e. the DH key can be read by all readers of x and y (set union) since it's sufficient
// to either know x or y as the public key is public.
// note that one must make sure the postconditions to not specify multiple labels for the same term, which
// would immediately be a contradiction. Thus, the case where t1 is an exponent of the generator and another term `e1` has to be explicitly excluded
// as this case is already covered via `mult`, i.e. (g^e1)^t2 == g^(e1 * t2)
ensures forall t1, t2 tm.Term :: { tm.mult(t1, t2) } term == tm.mult(t1, t2) ==> res == label.Join(ctx.GetLabel(t1), ctx.GetLabel(t2))
ensures forall t1, t2 tm.Term :: { tm.exp(t1, t2) } term == tm.exp(t1, t2) ==>
    (t1.IsGenerator() && t2.IsRandom() ? res == label.Public() :
        t1.IsGenerator() /* && !t2.IsRandom() */ ? res == ctx.GetLabel(t2) :
            !(exists e1 tm.Term :: { tm.exp(tm.generator(), e1) } t1 == tm.exp(tm.generator(), e1)) ==> res == label.Meet(ctx.GetLabel(t1), ctx.GetLabel(t2)))
/**
  * WARNING:
  * 2 terms that are equal based on the equational theory must return the same label!
  */
pure func (ctx DefaultLabelingContext) GetLabel(term tm.Term) (res label.SecrecyLabel)


ghost
requires t.IsTuple()
ensures  len(res) == t.GetTupleArity()
ensures  forall i int :: 0 <= i && i < t.GetTupleArity() ==> res[i] == tm.getTupleElem(t, i)
pure func getTupleSeq(t tm.Term) (res seq[tm.Term]) {
    return t.IsTuple2() ? seq[tm.Term]{ tm.getTupleElem(t, 0), tm.getTupleElem(t, 1) } :
            t.IsTuple3() ? seq[tm.Term]{ tm.getTupleElem(t, 0), tm.getTupleElem(t, 1), tm.getTupleElem(t, 2) } :
            t.IsTuple4() ? seq[tm.Term]{ tm.getTupleElem(t, 0), tm.getTupleElem(t, 1), tm.getTupleElem(t, 2), tm.getTupleElem(t, 3) } :
            t.IsTuple5() ? seq[tm.Term]{ tm.getTupleElem(t, 0), tm.getTupleElem(t, 1), tm.getTupleElem(t, 2), tm.getTupleElem(t, 3), tm.getTupleElem(t, 4) } :
            // t.IsTuple6() ? seq[tm.Term]{ tm.getTupleElem(t, 0), tm.getTupleElem(t, 1), tm.getTupleElem(t, 2), tm.getTupleElem(t, 3), tm.getTupleElem(t, 4), tm.getTupleElem(t, 5) } :
                seq[tm.Term]{ tm.getTupleElem(t, 0), tm.getTupleElem(t, 1), tm.getTupleElem(t, 2), tm.getTupleElem(t, 3), tm.getTupleElem(t, 4), tm.getTupleElem(t, 5), tm.getTupleElem(t, 6) }
}

ghost
requires 0 <= startIdx && startIdx + 2 <= len(terms)
pure func (ctx DefaultLabelingContext) nestedMeet(terms seq[tm.Term], startIdx int) label.SecrecyLabel {
    return startIdx + 2 == len(terms) ? label.Meet(ctx.GetLabel(terms[startIdx]), ctx.GetLabel(terms[startIdx + 1])) :
            label.Meet(ctx.GetLabel(terms[startIdx]), ctx.nestedMeet(terms, startIdx + 1))
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) GetUsage(t tm.Term) option[u.Usage] {
    return unfolding acc(ctx.Pred(), _) in ctx.usage.GetUsage(t)
}

ghost
requires acc(ctx.Pred(), _)
/** wrapper to get and check usage of a term for convenience */
pure func (ctx DefaultLabelingContext) IsPkeKey(sk tm.Term) bool {
    return (ctx.GetUsage(sk) != none[u.Usage]) && (get(ctx.GetUsage(sk))).IsPkeKey()
}

ghost
requires acc(ctx.Pred(), _)
/** wrapper to get and check usage of a term for convenience */
pure func (ctx DefaultLabelingContext) HasAeadKeyUsage(key tm.Term) bool {
    return (ctx.GetUsage(key) != none[u.Usage]) && (get(ctx.GetUsage(key))).IsAeadKey()
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) IsMsg(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) bool {
    return ctx.IsValid(t, term) &&
        ctx.CanFlow(t, ctx.GetLabel(term), l)
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsMsg(t1, term, l)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsMsg(t2, term, l)
func (ctx DefaultLabelingContext) IsMsgMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel, p perm) {
    ctx.IsValidMonotonic(t1, t2, term, p)
    ctx.CanFlowMonotonic(t1, t2, ctx.GetLabel(term), l)
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.CanFlow(t, l1, l2)
requires ctx.IsMsg(t, term, l1)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsMsg(t, term, l2)
func (ctx DefaultLabelingContext) IsMsgTransitive(t tr.TraceEntry, term tm.Term, l1, l2 label.SecrecyLabel, p perm) {
    ctx.CanFlowTransitive(t, ctx.GetLabel(term), l1, l2)
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires term.IsTuple()
requires forall i int :: { tm.getTupleElem(term, i) } 0 <= i && i < term.GetTupleArity() ==> ctx.IsMsg(t, tm.getTupleElem(term, i), l)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsMsg(t, term, l)
/** lemma for tuples having same label */
func (ctx DefaultLabelingContext) IsMsgTupleCreate(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel, p perm) {
    n := term.GetTupleArity()
    terms := getTupleSeq(term)
    secondToLastT := terms[n-2]
    secondToLastL := ctx.GetLabel(secondToLastT)
    lastT := terms[n-1]
    lastL := ctx.GetLabel(lastT)
    ctx.CanFlowCreateMeetLhs(t, secondToLastL, lastL, l)
    prevLabel := ctx.nestedMeet(terms, n - 2)

    invariant 0 <= i && i <= n - 2
    invariant len(getTupleSeq(term)) == n
    invariant prevLabel == ctx.nestedMeet(terms, i)
    invariant ctx.CanFlow(t, prevLabel, l)
    decreases i
    for i := n - 2; i >= 1; i-- {
        curT := terms[i-1]
        curL := ctx.GetLabel(curT)
        ctx.CanFlowCreateMeetLhs(t, curL, prevLabel, l)
        prevLabel = label.Meet(curL, prevLabel)
    }
   
    firstL := ctx.GetLabel(tm.getTupleElem(term, 0))
    ctx.CanFlowReflexive(t, l)
    ctx.CanFlowCreateMeetLhs(t, firstL, l, l)
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires term.IsTuple()
requires ctx.IsMsg(t, term, l)
ensures  acc(ctx.Pred(), p)
ensures  forall i int :: { tm.getTupleElem(term, i) } 0 <= i && i < term.GetTupleArity() ==> ctx.IsMsg(t, tm.getTupleElem(term, i), l)
/** lemma for tuples flowing to some label */
func (ctx DefaultLabelingContext) IsMsgTupleResolve(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel, p perm) {
    n := term.GetTupleArity()
    terms := getTupleSeq(term)

    invariant 0 <= i && i <= n - 2
    invariant acc(ctx.Pred(), p / 2)
    invariant len(getTupleSeq(term)) == n
    invariant ctx.CanFlow(t, ctx.nestedMeet(terms, i), l)
    invariant forall j int :: { tm.getTupleElem(term, j) } 0 <= j && j < i ==> ctx.IsMsg(t, tm.getTupleElem(term, j), l)
    decreases n - i
    for i := 0; i < n - 2; i++ {
        curT := tm.getTupleElem(term, i)
        curL := ctx.GetLabel(curT)
        remL := ctx.nestedMeet(terms, i + 1)
        ctx.CanFlowResolveMeetLhs(t, curL, remL, l)
    }
    secondToLastT := tm.getTupleElem(term, n - 2)
    secondToLastL := ctx.GetLabel(secondToLastT)
    lastT := tm.getTupleElem(term, n - 1)
    lastL := ctx.GetLabel(lastT)
    ctx.CanFlowResolveMeetLhs(t, secondToLastL, lastL, l)
}

ghost
decreases
requires ctx.CanFlow(t, l1, l3)
requires ctx.CanFlow(t, l2, l3)
ensures  ctx.CanFlow(t, label.Meet(l1, l2), l3)
func (ctx DefaultLabelingContext) CanFlowCreateMeetLhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalCreateMeetLhs(t.getCorruptIds(), l1, l2, l3)
}

ghost
decreases
requires ctx.canFlowInternal(corruptIds, l1, l3)
requires ctx.canFlowInternal(corruptIds, l2, l3)
ensures  ctx.canFlowInternal(corruptIds, label.Meet(l1, l2), l3)
func (ctx DefaultLabelingContext) canFlowInternalCreateMeetLhs(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l3)
    ctx.canFlowInternalImpliesDYStar(corruptIds, l2, l3)
    ctx.canFlowInternalCreateMeetLhs_DYStar(corruptIds, l1, l2, l3)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, label.Meet(l1, l2), l3)
}

ghost
decreases
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
requires ctx.canFlowInternal_DYStar(corruptIds, l2, l3)
ensures  ctx.canFlowInternal_DYStar(corruptIds, label.Meet(l1, l2), l3)
func (ctx DefaultLabelingContext) canFlowInternalCreateMeetLhs_DYStar(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel) {
    // no body needed
}

ghost
decreases
requires ctx.CanFlow(t, label.Meet(l1, l2), l3)
ensures  ctx.CanFlow(t, l1, l3)
ensures  ctx.CanFlow(t, l2, l3)
func (ctx DefaultLabelingContext) CanFlowResolveMeetLhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalResolveMeetLhs(t.getCorruptIds(), l1, l2, l3)
}

ghost
decreases
requires ctx.canFlowInternal(corruptIds, label.Meet(l1, l2), l3)
ensures  ctx.canFlowInternal(corruptIds, l1, l3)
ensures  ctx.canFlowInternal(corruptIds, l2, l3)
func (ctx DefaultLabelingContext) canFlowInternalResolveMeetLhs(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalImpliesDYStar(corruptIds, label.Meet(l1, l2), l3)
    ctx.canFlowInternalResolveMeetLhs_DYStar(corruptIds, l1, l2, l3)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l3)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l2, l3)
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
requires ctx.canFlowInternal_DYStar(corruptIds, label.Meet(l1, l2), l3)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l2, l3)
func (ctx DefaultLabelingContext) canFlowInternalResolveMeetLhs_DYStar(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel) {
    if (l3.IsMeet() || l3.IsJoin()) {
        if (ctx.canFlowInternal_DYStar(corruptIds, label.Meet(l1, l2), label.GetFirstLabel(l3))) {
            ctx.canFlowInternalResolveMeetLhs_DYStar(corruptIds, l1, l2, label.GetFirstLabel(l3))
        }
        if (ctx.canFlowInternal_DYStar(corruptIds, label.Meet(l1, l2), label.GetSecondLabel(l3))) {
            ctx.canFlowInternalResolveMeetLhs_DYStar(corruptIds, l1, l2, label.GetSecondLabel(l3))
        }
    }
}

ghost
decreases
requires ctx.CanFlow(t, l1, l2) || ctx.CanFlow(t, l1, l3)
ensures  ctx.CanFlow(t, l1, label.Meet(l2, l3))
func (ctx DefaultLabelingContext) CanFlowCreateMeetRhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalCreateMeetRhs(t.getCorruptIds(), l1, l2, l3)
}

ghost
decreases
requires ctx.canFlowInternal(corruptIds, l1, l2) || ctx.canFlowInternal(corruptIds, l1, l3)
ensures  ctx.canFlowInternal(corruptIds, l1, label.Meet(l2, l3))
func (ctx DefaultLabelingContext) canFlowInternalCreateMeetRhs(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel) {
    if ctx.canFlowInternal(corruptIds, l1, l2) {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l2)
    }
    if ctx.canFlowInternal(corruptIds, l1, l3) {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l3)
    }
    ctx.canFlowInternalCreateMeetRhs_DYStar(corruptIds, l1, l2, l3)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, label.Meet(l2, l3))
}

ghost
decreases
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l2) || ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, label.Meet(l2, l3))
func (ctx DefaultLabelingContext) canFlowInternalCreateMeetRhs_DYStar(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel) {
    // no body needed
}

ghost
requires ctx.CanFlow(t, l1, l2)
requires ctx.CanFlow(t, l3, l4)
ensures  ctx.CanFlow(t, label.Meet(l1, l3), label.Meet(l2, l4))
func (ctx DefaultLabelingContext) CanFlowCreateMeetBoth(t tr.TraceEntry, l1, l2, l3, l4 label.SecrecyLabel) {
    ctx.canFlowInternalCreateMeetBoth(t.getCorruptIds(), l1, l2, l3, l4)
}

ghost
requires ctx.canFlowInternal(corruptIds, l1, l2)
requires ctx.canFlowInternal(corruptIds, l3, l4)
ensures  ctx.canFlowInternal(corruptIds, label.Meet(l1, l3), label.Meet(l2, l4))
func (ctx DefaultLabelingContext) canFlowInternalCreateMeetBoth(corruptIds set[Id], l1, l2, l3, l4 label.SecrecyLabel) {
    ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l2)
    ctx.canFlowInternalImpliesDYStar(corruptIds, l3, l4)
    ctx.canFlowInternalCreateMeetBoth_DYStar(corruptIds, l1, l2, l3, l4)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, label.Meet(l1, l3), label.Meet(l2, l4))
}

ghost
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
requires ctx.canFlowInternal_DYStar(corruptIds, l3, l4)
ensures  ctx.canFlowInternal_DYStar(corruptIds, label.Meet(l1, l3), label.Meet(l2, l4))
func (ctx DefaultLabelingContext) canFlowInternalCreateMeetBoth_DYStar(corruptIds set[Id], l1, l2, l3, l4 label.SecrecyLabel) {
    ctx.canFlowInternalCreateMeetRhs_DYStar(corruptIds, l1, l2, l4)
    ctx.canFlowInternalCreateMeetRhs_DYStar(corruptIds, l3, l2, l4)
}

ghost
requires ctx.CanFlow(t, l1, l2)
requires ctx.CanFlow(t, l3, l4)
ensures  ctx.CanFlow(t, label.Join(l1, l3), label.Join(l2, l4))
func (ctx DefaultLabelingContext) CanFlowCreateJoinBoth(t tr.TraceEntry, l1, l2, l3, l4 label.SecrecyLabel) {
    ctx.canFlowInternalCreateJoinBoth(t.getCorruptIds(), l1, l2, l3, l4)
}

ghost
requires ctx.canFlowInternal(corruptIds, l1, l2)
requires ctx.canFlowInternal(corruptIds, l3, l4)
ensures  ctx.canFlowInternal(corruptIds, label.Join(l1, l3), label.Join(l2, l4))
func (ctx DefaultLabelingContext) canFlowInternalCreateJoinBoth(corruptIds IdSet, l1, l2, l3, l4 label.SecrecyLabel) {
    ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l2)
    ctx.canFlowInternalImpliesDYStar(corruptIds, l3, l4)
    ctx.canFlowInternalCreateJoinBoth_DYStar(corruptIds, l1, l2, l3, l4)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, label.Join(l1, l3), label.Join(l2, l4))
}

ghost
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
requires ctx.canFlowInternal_DYStar(corruptIds, l3, l4)
ensures  ctx.canFlowInternal_DYStar(corruptIds, label.Join(l1, l3), label.Join(l2, l4))
func (ctx DefaultLabelingContext) canFlowInternalCreateJoinBoth_DYStar(corruptIds IdSet, l1, l2, l3, l4 label.SecrecyLabel) {
    ctx.canFlowInternalCreateJoinLhs_DYStar(corruptIds, l1, l3, l2)
    ctx.canFlowInternalCreateJoinLhs_DYStar(corruptIds, l1, l3, l4)
}

ghost
decreases
requires ctx.CanFlow(t, l1, label.Meet(l2, l3))
requires ctx.CanFlow(t, l2, l3)
ensures  ctx.CanFlow(t, l1, l3)
func (ctx DefaultLabelingContext) CanFlowResolveMeetRhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalResolveMeetRhs(t.getCorruptIds(), l1, l2, l3)
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
requires ctx.canFlowInternal(corruptIds, l1, label.Meet(l2, l3))
requires ctx.canFlowInternal(corruptIds, l2, l3)
ensures  ctx.canFlowInternal(corruptIds, l1, l3)
func (ctx DefaultLabelingContext) canFlowInternalResolveMeetRhs(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalImpliesDYStar(corruptIds, l1, label.Meet(l2, l3))
    ctx.canFlowInternalImpliesDYStar(corruptIds, l2, l3)
    ctx.canFlowInternalResolveMeetRhs_DYStar(corruptIds, l1, l2, l3)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l3)
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
requires ctx.canFlowInternal_DYStar(corruptIds, l1, label.Meet(l2, l3))
requires ctx.canFlowInternal_DYStar(corruptIds, l2, l3)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
func (ctx DefaultLabelingContext) canFlowInternalResolveMeetRhs_DYStar(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel) {
    if ctx.canFlowInternal_DYStar(corruptIds, l1, l2) {
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l2, l3)
    }
    if l1.IsMeet() {
        if !ctx.canFlowInternal_DYStar(corruptIds, l1, l3) {
            ctx.canFlowInternalResolveMeetRhs_DYStar(corruptIds, label.GetFirstLabel(l1), l2, l3)
            ctx.canFlowInternalResolveMeetRhs_DYStar(corruptIds, label.GetSecondLabel(l1), l2, l3)
        }
    } else if l1.IsJoin() {
        if ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), label.Meet(l2, l3)) {
            ctx.canFlowInternalResolveMeetRhs_DYStar(corruptIds, label.GetFirstLabel(l1), l2, l3)
        } else if ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), label.Meet(l2, l3)) {
            ctx.canFlowInternalResolveMeetRhs_DYStar(corruptIds, label.GetSecondLabel(l1), l2, l3)
        }
    }
}

ghost
decreases
requires ctx.CanFlow(t, l1, l3) || ctx.CanFlow(t, l2, l3)
ensures  ctx.CanFlow(t, label.Join(l1, l2), l3)
func (ctx DefaultLabelingContext) CanFlowCreateJoinLhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalCreateJoinLhs(t.getCorruptIds(), l1, l2, l3)
}

ghost
decreases
requires ctx.canFlowInternal(corruptIds, l1, l3) || ctx.canFlowInternal(corruptIds, l2, l3)
ensures  ctx.canFlowInternal(corruptIds, label.Join(l1, l2), l3)
func (ctx DefaultLabelingContext) canFlowInternalCreateJoinLhs(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel) {
    if ctx.canFlowInternal(corruptIds, l1, l3) {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l3)
    } else {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l2, l3)
    }
    ctx.canFlowInternalCreateJoinLhs_DYStar(corruptIds, l1, l2, l3)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, label.Join(l1, l2), l3)
}

ghost
decreases
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l3) || ctx.canFlowInternal_DYStar(corruptIds, l2, l3)
ensures  ctx.canFlowInternal_DYStar(corruptIds, label.Join(l1, l2), l3)
func (ctx DefaultLabelingContext) canFlowInternalCreateJoinLhs_DYStar(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel) {
    // no body needed
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
requires ctx.canFlowInternal_DYStar(corruptIds, label.Join(l1, l1), l2)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
// note that it does not hold that ctx.canFlowInternal_DYStar(corruptIds, label.Join(l1, l2), l3) ==>
//    (ctx.canFlowInternal_DYStar(corruptIds, l1, l3) ||
//     ctx.canFlowInternal_DYStar(corruptIds, l2, l3))
// the lhs is weaker because it permits that l1 flows to l31 and l2 to l32 (if l3 == Meet(l31, l32))
func (ctx DefaultLabelingContext) canFlowInternalResolveJoinLhs_DYStar(corruptIds set[Id], l1, l2 label.SecrecyLabel) {
    if (l2.IsMeet()) {
        if (ctx.canFlowInternal_DYStar(corruptIds, label.Join(l1, l1), label.GetFirstLabel(l2))) {
            ctx.canFlowInternalResolveJoinLhs_DYStar(corruptIds, l1, label.GetFirstLabel(l2))
        } else if (ctx.canFlowInternal_DYStar(corruptIds, label.Join(l1, l1), label.GetSecondLabel(l2))) {
            ctx.canFlowInternalResolveJoinLhs_DYStar(corruptIds, l1, label.GetSecondLabel(l2))
        }
    } else if (l2.IsJoin()) {
        if (!ctx.canFlowInternal_DYStar(corruptIds, l1, l2)) {
            ctx.canFlowInternalResolveJoinLhs_DYStar(corruptIds, l1, label.GetFirstLabel(l2))
            ctx.canFlowInternalResolveJoinLhs_DYStar(corruptIds, l1, label.GetSecondLabel(l2))
        }
    }
}

ghost
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, label.Join(l2, l3))
func (ctx DefaultLabelingContext) canFlowInternalCreateJoinRhs_DYStar(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel) {
    // no body needed
}

ghost
decreases
requires ctx.CanFlow(t, l1, label.Join(l2, l3))
ensures  ctx.CanFlow(t, l1, l2)
ensures  ctx.CanFlow(t, l1, l3)
func (ctx DefaultLabelingContext) CanFlowResolveJoinRhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalResolveJoinRhs(t.getCorruptIds(), l1, l2, l3)
}

ghost
decreases
requires ctx.canFlowInternal(corruptIds, l1, label.Join(l2, l3))
ensures  ctx.canFlowInternal(corruptIds, l1, l2)
ensures  ctx.canFlowInternal(corruptIds, l1, l3)
func (ctx DefaultLabelingContext) canFlowInternalResolveJoinRhs(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalImpliesDYStar(corruptIds, l1, label.Join(l2, l3))
    ctx.canFlowInternalResolveJoinRhs_DYStar(corruptIds, l1, l2, l3)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l2)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l3)
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
requires ctx.canFlowInternal_DYStar(corruptIds, l1, label.Join(l2, l3))
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
func (ctx DefaultLabelingContext) canFlowInternalResolveJoinRhs_DYStar(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel) {
    if (l1.IsMeet() || l1.IsJoin()) {
        if (ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), label.Join(l2, l3))) {
            ctx.canFlowInternalResolveJoinRhs_DYStar(corruptIds, label.GetFirstLabel(l1), l2, l3)
        }
        if (ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), label.Join(l2, l3))) {
            ctx.canFlowInternalResolveJoinRhs_DYStar(corruptIds, label.GetSecondLabel(l1), l2, l3)
        }
    }
}

ghost
decreases
requires ctx.CanFlow(t, l1, label.Meet(l2, l3))
requires  l2FlowsToPublic ==> ctx.CanFlow(t, l2, label.Public())
requires !l2FlowsToPublic ==> ctx.CanFlow(t, l3, label.Public())
ensures   l2FlowsToPublic ==> ctx.CanFlow(t, l1, l3)
ensures  !l2FlowsToPublic ==> ctx.CanFlow(t, l1, l2)
func (ctx DefaultLabelingContext) CanFlowResolveMeetPublicRhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel, l2FlowsToPublic bool) {
    ctx.canFlowInternalResolveMeetPublicRhs(t.getCorruptIds(), l1, l2, l3, l2FlowsToPublic)
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
requires ctx.canFlowInternal(corruptIds, l1, label.Meet(l2, l3))
requires  l2FlowsToPublic ==> ctx.canFlowInternal(corruptIds, l2, label.Public())
requires !l2FlowsToPublic ==> ctx.canFlowInternal(corruptIds, l3, label.Public())
ensures   l2FlowsToPublic ==> ctx.canFlowInternal(corruptIds, l1, l3)
ensures  !l2FlowsToPublic ==> ctx.canFlowInternal(corruptIds, l1, l2)
func (ctx DefaultLabelingContext) canFlowInternalResolveMeetPublicRhs(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel, l2FlowsToPublic bool) {
    ctx.canFlowInternalImpliesDYStar(corruptIds, l1, label.Meet(l2, l3))
    if l2FlowsToPublic {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l2, label.Public())
    } else {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l3, label.Public())
    }
    ctx.canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds, l1, l2, l3, l2FlowsToPublic)
    if l2FlowsToPublic {
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l3)
    } else {
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l2)
    }
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
requires ctx.canFlowInternal_DYStar(corruptIds, l1, label.Meet(l2, l3))
requires  l2FlowsToPublic ==> ctx.canFlowInternal_DYStar(corruptIds, l2, label.Public())
requires !l2FlowsToPublic ==> ctx.canFlowInternal_DYStar(corruptIds, l3, label.Public())
ensures   l2FlowsToPublic ==> ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
ensures  !l2FlowsToPublic ==> ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
func (ctx DefaultLabelingContext) canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel, l2FlowsToPublic bool) {
    if (ctx.canFlowInternal_DYStar(corruptIds, l1, label.Public())) {
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l1, l2)
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l1, l3)
    }
    if ctx.canFlowInternal_DYStar(corruptIds, l1, l2) {
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l2, label.Public())
    }
    if ctx.canFlowInternal_DYStar(corruptIds, l1, l3) {
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l3, label.Public())
    }

    if (l1.IsMeet()) {
        if (!ctx.canFlowInternal_DYStar(corruptIds, l1, l2) && !ctx.canFlowInternal_DYStar(corruptIds, l1, l3)) {
            ctx.canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds, label.GetFirstLabel(l1), l2, l3, l2FlowsToPublic)
            ctx.canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds, label.GetSecondLabel(l1), l2, l3, l2FlowsToPublic)
        }
    } else if (l1.IsJoin()) {
        if (ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), label.Meet(l2, l3))) {
            ctx.canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds, label.GetFirstLabel(l1), l2, l3, l2FlowsToPublic)
        } else if (ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), label.Meet(l2, l3))) {
            ctx.canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds, label.GetSecondLabel(l1), l2, l3, l2FlowsToPublic)
        }
    }
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) IsPublishable(t tr.TraceEntry, term tm.Term) bool {
    return ctx.IsMsg(t, term, label.Public())
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsPublishable(t1, term)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsPublishable(t2, term)
func (ctx DefaultLabelingContext) IsPublishableMonotonic(t1, t2 tr.TraceEntry, term tm.Term, p perm) {
    ctx.IsMsgMonotonic(t1, t2, term, label.Public(), p)
}

ghost
pure func (ctx DefaultLabelingContext) CanFlow(t tr.TraceEntry, l1, l2 label.SecrecyLabel) bool {
    return ctx.canFlowInternal(t.getCorruptIds(), l1, l2)
}

ghost
/** this is the canFlowInternal function that we use throughout */
pure func (ctx DefaultLabelingContext) canFlowInternal(corruptIds set[Id], l1, l2 label.SecrecyLabel) bool {
    // public can flow to anything
    return l1.IsPublic() ? true :
        ////////// begin special cases //////////
        // begin special case 1: meet or join of two identical labels is identical to one of them (l1 case)
        ((l1.IsMeet() || l1.IsJoin()) && label.GetFirstLabel(l1) == label.GetSecondLabel(l1)) ? ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) :
        // end special case 1
        // begin special case 2: meet or join of two identical labels is identical to one of them (l2 case)
        ((l2.IsMeet() || l2.IsJoin()) && label.GetFirstLabel(l2) == label.GetSecondLabel(l2)) ? ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) :
        // end special case 2
        // begin special case 3: meet of two labels, one of which being public (l1 case)
        (l1.IsMeet() && label.GetFirstLabel(l1).IsPublic()) ? ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2) :
        (l1.IsMeet() && label.GetSecondLabel(l1).IsPublic()) ? ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) :
        // end special case 3
        // begin special case 4: meet of two labels, one of which being public (l2 case)
        (l2.IsMeet() && label.GetFirstLabel(l2).IsPublic()) ? ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2)) :
        (l2.IsMeet() && label.GetSecondLabel(l2).IsPublic()) ? ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) :
        // end special case 4
        ////////// end special cases //////////
        // label with a corrupted reader flows to public
        (l1.IsReaders() && l2.IsPublic()) ? tr.containsCorruptId(corruptIds, label.GetReaders(l1)) :
        // l1 is superset of l2 or some ID in l1 is corrupt
        (l1.IsReaders() && l2.IsReaders()) ? (includesIds(label.GetReaders(l1), label.GetReaders(l2)) || tr.containsCorruptId(corruptIds, label.GetReaders(l1))) :
        // l1 flows to l2 == meet(l21, l22) if l1 flows to l21 OR l22 because meet(l21, l22) is stricter than l21 or l22
        (l1.IsReaders() && l2.IsMeet()) ? (ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) :
        // l1 flows to l2 == join(l21, l22) if l1 flows to l21 AND l22
        (l1.IsReaders() && l2.IsJoin()) ? (ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) :
        (l1.IsJoin() && (l2.IsPublic() || l2.IsReaders())) ? (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2)) :
        (l1.IsMeet() && (l2.IsPublic() || l2.IsReaders())) ? (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2)) :
        (l1.IsJoin() && l2.IsMeet()) ? ((ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2))) :
        (l1.IsMeet() && l2.IsMeet()) ? ((ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2))) :
        (l1.IsMeet() && l2.IsJoin()) ? ((ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2))) :
        (l1.IsJoin() && l2.IsJoin()) ? ((ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2))) :
            false
        // rule of thumb:
        // l1 being a join or l2 being a meet results in disjunctions
        // l1 being a meet or l2 being a join results in conjunctions
}

ghost
/** 
  * this is the orginal `can_flow` function used by DY*.
  * we show below that `canFlowInternal` and `canFlowInternal_DYStar` are equivalent.
  */
pure func (ctx DefaultLabelingContext) canFlowInternal_DYStar(corruptIds set[Id], l1, l2 label.SecrecyLabel) bool {
    // public can flow to anything
    return (l1.IsPublic() ==> true) &&
        // label with a corrupted reader flows to public
        (l1.IsReaders() && l2.IsPublic() ==> tr.containsCorruptId(corruptIds, label.GetReaders(l1))) &&
        // l1 is superset of l2 or some ID in l1 is corrupt
        (l1.IsReaders() && l2.IsReaders() ==> (includesIds(label.GetReaders(l1), label.GetReaders(l2)) || tr.containsCorruptId(corruptIds, label.GetReaders(l1)))) &&
        // l1 flows to l2 == meet(l21, l22) if l1 flows to l21 OR l22 because meet(l21, l22) is stricter than l21 or l22
        (l1.IsReaders() && l2.IsMeet() ==> ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetSecondLabel(l2))) &&
        // l1 flows to l2 == join(l21, l22) if l1 flows to l21 AND l22
        (l1.IsReaders() && l2.IsJoin() ==> ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetSecondLabel(l2))) &&
        (l1.IsJoin() && (l2.IsPublic() || l2.IsReaders()) ==> ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), l2)) &&
        (l1.IsMeet() && (l2.IsPublic() || l2.IsReaders()) ==> ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), l2)) &&
        (l1.IsJoin() && l2.IsMeet() ==> (ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), l2))) &&
        (l1.IsMeet() && l2.IsMeet() ==> (ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), l2))) &&
        (l1.IsMeet() && l2.IsJoin() ==> (ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), l2))) &&
        (l1.IsJoin() && l2.IsJoin() ==> (ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), l2)))
        // rule of thumb:
        // l1 being a join or l2 being a meet results in disjunctions
        // l1 being a meet or l2 being a join results in conjunctions
}

ghost
decreases _ // TODO termination via label ADT
requires ctx.canFlowInternal(corruptIds, l1, l2)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
func (ctx DefaultLabelingContext) canFlowInternalImpliesDYStar(corruptIds set[Id], l1, l2 label.SecrecyLabel) {
    if (l1.IsMeet() || l1.IsJoin()) && label.GetFirstLabel(l1) == label.GetSecondLabel(l1) {
        // special case 1
        l11 := label.GetFirstLabel(l1)
        ctx.canFlowInternalImpliesDYStar(corruptIds, l11, l2)
        if l1.IsMeet() {
            ctx.canFlowInternalCreateMeetLhs_DYStar(corruptIds, l11, l11, l2)
        } else {
            ctx.canFlowInternalCreateJoinLhs_DYStar(corruptIds, l11, l11, l2)
        }
    } else if (l2.IsMeet() || l2.IsJoin()) && label.GetFirstLabel(l2) == label.GetSecondLabel(l2) {
        // special case 2
        l21 := label.GetFirstLabel(l2)
        ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l21)
        if l1.IsMeet() {
            ctx.canFlowInternalCreateMeetRhs_DYStar(corruptIds, l1, l21, l21)
        } else {
            ctx.canFlowInternalCreateJoinRhs_DYStar(corruptIds, l1, l21, l21)
        }
    } else if l1.IsMeet() && (label.GetFirstLabel(l1).IsPublic() || label.GetSecondLabel(l1).IsPublic()) {
        // special case 3
        l11 := label.GetFirstLabel(l1)
        l12 := label.GetSecondLabel(l1)
        ctx.canFlowInternalImpliesDYStar(corruptIds, l11, l2)
        ctx.canFlowInternalImpliesDYStar(corruptIds, l12, l2)
        ctx.canFlowInternalCreateMeetLhs_DYStar(corruptIds, l11, l12, l2)
    } else if l2.IsMeet() && (label.GetFirstLabel(l2).IsPublic() || label.GetSecondLabel(l2).IsPublic()) {
        // special case 4
        l21 := label.GetFirstLabel(l2)
        l22 := label.GetSecondLabel(l2)
        if ctx.canFlowInternal(corruptIds, l1, l21) {
            ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l21)
        }
        if ctx.canFlowInternal(corruptIds, l1, l22) {
            ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l22)
        }
        ctx.canFlowInternalCreateMeetRhs_DYStar(corruptIds, l1, l21, l22)
    } else {
        if l1.IsMeet() || l1.IsJoin() {
            l11 := label.GetFirstLabel(l1)
            l12 := label.GetSecondLabel(l1)
            if ctx.canFlowInternal(corruptIds, l11, l2) {
                ctx.canFlowInternalImpliesDYStar(corruptIds, l11, l2)
            }
            if ctx.canFlowInternal(corruptIds, l12, l2) {
                ctx.canFlowInternalImpliesDYStar(corruptIds, l12, l2)
            }
        }
        if l2.IsMeet() || l2.IsJoin() {
            l21 := label.GetFirstLabel(l2)
            l22 := label.GetSecondLabel(l2)
            if ctx.canFlowInternal(corruptIds, l1, l21) {
                ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l21)
            }
            if ctx.canFlowInternal(corruptIds, l1, l22) {
                ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l22)
            }
        }
    }
}

ghost
decreases _ // TODO termination via label ADT
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
ensures  ctx.canFlowInternal(corruptIds, l1, l2)
func (ctx DefaultLabelingContext) canFlowInternalIsImpliesByDYStar(corruptIds set[Id], l1, l2 label.SecrecyLabel) {
    if (l1.IsMeet() || l1.IsJoin()) && label.GetFirstLabel(l1) == label.GetSecondLabel(l1) {
        // special case 1
        l11 := label.GetFirstLabel(l1)
        if l1.IsMeet() {
            ctx.canFlowInternalResolveMeetLhs_DYStar(corruptIds, l11, l11, l2)
        } else {
            ctx.canFlowInternalResolveJoinLhs_DYStar(corruptIds, l11, l2)
        }
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l11, l2)
    } else if (l2.IsMeet() || l2.IsJoin()) && label.GetFirstLabel(l2) == label.GetSecondLabel(l2) {
        // special case 2
        l21 := label.GetFirstLabel(l2)
        if l2.IsMeet() {
            ctx.canFlowInternalReflexive_DYStar(corruptIds, l21)
            ctx.canFlowInternalResolveMeetRhs_DYStar(corruptIds, l1, l21, l21)
        } else {
            ctx.canFlowInternalResolveJoinRhs_DYStar(corruptIds, l1, l21, l21)
        }
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l21)
    } else if l1.IsMeet() && (label.GetFirstLabel(l1).IsPublic() || label.GetSecondLabel(l1).IsPublic()) {
        // special case 3
        l11 := label.GetFirstLabel(l1)
        l12 := label.GetSecondLabel(l1)
        ctx.canFlowInternalResolveMeetLhs_DYStar(corruptIds, l11, l12, l2)
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l12, l2)
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l11, l2)
    } else if l2.IsMeet() && (label.GetFirstLabel(l2).IsPublic() || label.GetSecondLabel(l2).IsPublic()) {
        // special case 4
        l21 := label.GetFirstLabel(l2)
        l22 := label.GetSecondLabel(l2)
        ctx.canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds, l1, l21, l22, l21.IsPublic())
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l2)
    } else {
        if l1.IsMeet() || l1.IsJoin() {
            l11 := label.GetFirstLabel(l1)
            l12 := label.GetSecondLabel(l1)
            if ctx.canFlowInternal_DYStar(corruptIds, l11, l2) {
                ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l11, l2)
            }
            if ctx.canFlowInternal_DYStar(corruptIds, l12, l2) {
                ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l12, l2)
            }
        }
        if l2.IsMeet() || l2.IsJoin() {
            l21 := label.GetFirstLabel(l2)
            l22 := label.GetSecondLabel(l2)
            if ctx.canFlowInternal_DYStar(corruptIds, l1, l21) {
                ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l21)
            }
            if ctx.canFlowInternal_DYStar(corruptIds, l1, l22) {
                ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l22)
            }
        }
    }
}

ghost
decreases
ensures  ctx.CanFlow(t, l, l)
func (ctx DefaultLabelingContext) CanFlowReflexive(t tr.TraceEntry, l label.SecrecyLabel) {
    corruptIds := t.getCorruptIds()
    ctx.canFlowInternalReflexive(corruptIds, l)
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
ensures  ctx.canFlowInternal(corruptIds, l, l)
func (ctx DefaultLabelingContext) canFlowInternalReflexive(corruptIds set[Id], l label.SecrecyLabel) {
    ctx.canFlowInternalReflexive_DYStar(corruptIds, l)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l, l)
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
ensures  ctx.canFlowInternal_DYStar(corruptIds, l, l)
func (ctx DefaultLabelingContext) canFlowInternalReflexive_DYStar(corruptIds set[Id], l label.SecrecyLabel) {
    if l.IsReaders() {
        ctx.includesIdsReflexive(label.GetReaders(l))
    } else if (l.IsJoin()) {
        l1 := label.GetFirstLabel(l)
        l2 := label.GetSecondLabel(l)
        ctx.canFlowInternalReflexive_DYStar(corruptIds, l1)
        ctx.canFlowInternalReflexive_DYStar(corruptIds, l2)
        // the following assert stmts are needed
        assert ctx.canFlowInternal_DYStar(corruptIds, l, l1)
        assert ctx.canFlowInternal_DYStar(corruptIds, l, l2)
    } else if (l.IsMeet()) {
        l1 := label.GetFirstLabel(l)
        l2 := label.GetSecondLabel(l)
        ctx.canFlowInternalReflexive_DYStar(corruptIds, l1)
        ctx.canFlowInternalReflexive_DYStar(corruptIds, l2)
        // the following assert stmts are needed
        assert ctx.canFlowInternal_DYStar(corruptIds, l1, l)
        assert ctx.canFlowInternal_DYStar(corruptIds, l2, l)
    }
}

ghost
decreases
requires ctx.CanFlow(t, l1, l2)
requires ctx.CanFlow(t, l2, l3)
ensures  ctx.CanFlow(t, l1, l3)
func (ctx DefaultLabelingContext) CanFlowTransitive(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    corruptIds := t.getCorruptIds()
    ctx.canFlowInternalTransitive(corruptIds, l1, l2, l3)
}

ghost
decreases
ensures (ctx.canFlowInternal(corruptIds, l1, l2) && ctx.canFlowInternal(corruptIds, l2, l3)) ==> ctx.canFlowInternal(corruptIds, l1, l3)
func (ctx DefaultLabelingContext) canFlowInternalTransitive(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel) {
    if ctx.canFlowInternal(corruptIds, l1, l2) && ctx.canFlowInternal(corruptIds, l2, l3) {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l2)
        ctx.canFlowInternalImpliesDYStar(corruptIds, l2, l3)
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l2, l3)
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l3)
    }
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
ensures (ctx.canFlowInternal_DYStar(corruptIds, l1, l2) && ctx.canFlowInternal_DYStar(corruptIds, l2, l3)) ==> ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
func (ctx DefaultLabelingContext) canFlowInternalTransitive_DYStar(corruptIds set[Id], l1, l2, l3 label.SecrecyLabel) {
    if (l1.IsPublic()) {
        // no body needed
        return
    }
    if (l2.IsPublic()) {
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l1, l3)
        return
    }
    if (l3.IsPublic()) {
        ctx.canFlowFlowsToPublic_DYStar(corruptIds, l1, l2)
        return
    }

    if l1.IsReaders() && l2.IsReaders() && l3.IsReaders() &&
        includesIds(label.GetReaders(l1), label.GetReaders(l2)) &&
        includesIds(label.GetReaders(l2), label.GetReaders(l3)) {
        ctx.includesIdsTransitive(label.GetReaders(l1), label.GetReaders(l2), label.GetReaders(l3))
    }

    if l1.IsReaders() && l2.IsReaders() && l3.IsReaders() &&
        ctx.canFlowInternal_DYStar(corruptIds, l1, l2) &&
        ctx.canFlowInternal_DYStar(corruptIds, l2, l3) &&
        includesIds(label.GetReaders(l1), label.GetReaders(l2)) &&
        tr.containsCorruptId(corruptIds, label.GetReaders(l2)) {
        ctx.containsCorruptIdMonotonic(corruptIds, label.GetReaders(l2), label.GetReaders(l1))
    }

    if (l1.IsJoin() || l1.IsMeet()) {
        l11 := label.GetFirstLabel(l1)
        l12 := label.GetSecondLabel(l1)
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l11, l2, l3)
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l12, l2, l3)
    }
    if (l2.IsJoin() || l2.IsMeet()) {
        l21 := label.GetFirstLabel(l2)
        l22 := label.GetSecondLabel(l2)
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l21, l3)
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l22, l3)
    }
    if (l3.IsJoin() || l3.IsMeet()) {
        l31 := label.GetFirstLabel(l3)
        l32 := label.GetSecondLabel(l3)
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l2, l31)
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l2, l32)
    }
}

ghost
decreases
ensures  ctx.CanFlow(t, l1, label.Public()) ==> ctx.CanFlow(t, l1, l2)
func (ctx DefaultLabelingContext) FlowsToPublicCanFlow(t tr.TraceEntry, l1, l2 label.SecrecyLabel) {
    ctx.flowsToPublicCanFlowInternal(t.getCorruptIds(), l1, l2)
}

ghost
decreases _ // TODO why can't we show termination here?
ensures  ctx.canFlowInternal(corruptIds, l1, label.Public()) ==> ctx.canFlowInternal(corruptIds, l1, l2)
func (ctx DefaultLabelingContext) flowsToPublicCanFlowInternal(corruptIds set[Id], l1, l2 label.SecrecyLabel) {
    if ctx.canFlowInternal(corruptIds, l1, label.Public()) {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l1, label.Public())
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l1, l2)
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l2)
    }
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, label.Public()) ==> ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
func (ctx DefaultLabelingContext) flowsToPublicCanFlowInternal_DYStar(corruptIds set[Id], l1, l2 label.SecrecyLabel) {
    if (l1.IsJoin() || l1.IsMeet()) {
        l11 := label.GetFirstLabel(l1)
        l12 := label.GetSecondLabel(l1)
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l11, l2)
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l12, l2)
    }
    if (l2.IsJoin() || l2.IsMeet()) {
        l21 := label.GetFirstLabel(l2)
        l22 := label.GetSecondLabel(l2)
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l1, l21)
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l1, l22)
    }
}

ghost
decreases
ensures  (ctx.canFlowInternal(corruptIds, l2, label.Public()) && ctx.canFlowInternal(corruptIds, l1, l2)) ==> ctx.canFlowInternal(corruptIds, l1, label.Public())
func (ctx DefaultLabelingContext) canFlowFlowsToPublic(corruptIds set[Id], l1, l2 label.SecrecyLabel) {
    if ctx.canFlowInternal(corruptIds, l2, label.Public()) && ctx.canFlowInternal(corruptIds, l1, l2) {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l2, label.Public())
        ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l2)
        ctx.canFlowFlowsToPublic_DYStar(corruptIds, l1, l2)
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, label.Public())
    }
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
ensures  (ctx.canFlowInternal_DYStar(corruptIds, l2, label.Public()) && ctx.canFlowInternal_DYStar(corruptIds, l1, l2)) ==> ctx.canFlowInternal_DYStar(corruptIds, l1, label.Public())
func (ctx DefaultLabelingContext) canFlowFlowsToPublic_DYStar(corruptIds set[Id], l1, l2 label.SecrecyLabel) {
    if l1.IsReaders() && l2.IsReaders() &&
        ctx.canFlowInternal_DYStar(corruptIds, l2, label.Public()) &&
        ctx.canFlowInternal_DYStar(corruptIds, l1, l2) &&
        includesIds(label.GetReaders(l1), label.GetReaders(l2)) {
        ctx.containsCorruptIdMonotonic(corruptIds, label.GetReaders(l2), label.GetReaders(l1))
    }
    if (l1.IsJoin() || l1.IsMeet()) {
        l11 := label.GetFirstLabel(l1)
        l12 := label.GetSecondLabel(l1)
        ctx.canFlowFlowsToPublic_DYStar(corruptIds, l11, l2)
        ctx.canFlowFlowsToPublic_DYStar(corruptIds, l12, l2)
    }
    if (l2.IsJoin() || l2.IsMeet()) {
        l21 := label.GetFirstLabel(l2)
        l22 := label.GetSecondLabel(l2)
        ctx.canFlowFlowsToPublic_DYStar(corruptIds, l1, l21)
        ctx.canFlowFlowsToPublic_DYStar(corruptIds, l1, l22)
    }
}

ghost
requires l1.IsReaders() && l2.IsReaders()
requires label.GetReaders(l2) subset label.GetReaders(l1)
ensures  ctx.CanFlow(t, l1, l2)
func (ctx DefaultLabelingContext) CanFlowToSubsetReaders(t tr.TraceEntry, l1, l2 label.SecrecyLabel) {
    corruptIds := t.getCorruptIds()
    ctx.canFlowInternalToSubsetReaders(corruptIds, l1, l2)
}

ghost
requires l1.IsReaders() && l2.IsReaders()
requires label.GetReaders(l2) subset label.GetReaders(l1)
ensures  ctx.canFlowInternal(corruptIds, l1, l2)
func (ctx DefaultLabelingContext) canFlowInternalToSubsetReaders(corruptIds IdSet, l1, l2 label.SecrecyLabel) {
    ctx.canFlowInternalToSubsetReaders_DYStar(corruptIds, l1, l2)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l2)
}

ghost
requires l1.IsReaders() && l2.IsReaders()
requires label.GetReaders(l2) subset label.GetReaders(l1)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
func (ctx DefaultLabelingContext) canFlowInternalToSubsetReaders_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel) {
    ids1 := label.GetReaders(l1)
    ids2 := label.GetReaders(l2)
    ctx.includesIdsSubset(ids1, ids2)
}

ghost
decreases
requires t1.isSuffix(t2)
requires ctx.CanFlow(t1, l1, l2)
ensures  ctx.CanFlow(t2, l1, l2)
func (ctx DefaultLabelingContext) CanFlowMonotonic(t1, t2 tr.TraceEntry, l1, l2 label.SecrecyLabel) {
    ctx.CanFlowMonotonicInternal(t1, t2, l1, l2)
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
requires t1.isSuffix(t2)
ensures  ctx.CanFlow(t1, l1, l2) ==> ctx.CanFlow(t2, l1, l2)
func (ctx DefaultLabelingContext) CanFlowMonotonicInternal(t1, t2 tr.TraceEntry, l1, l2 label.SecrecyLabel) {
    if (!l1.IsJoin() && !l1.IsMeet() && !l2.IsJoin() && !l2.IsMeet()) {
        t1.getCorruptIdsMonotonic(t2)
    } else {
        if (l1.IsJoin() || l1.IsMeet()) {
            l11 := label.GetFirstLabel(l1)
            l12 := label.GetSecondLabel(l1)
            ctx.CanFlowMonotonicInternal(t1, t2, l11, l2)
            ctx.CanFlowMonotonicInternal(t1, t2, l12, l2)
        }
        if (l2.IsJoin() || l2.IsMeet()) {
            l21 := label.GetFirstLabel(l2)
            l22 := label.GetSecondLabel(l2)
            ctx.CanFlowMonotonicInternal(t1, t2, l1, l21)
            ctx.CanFlowMonotonicInternal(t1, t2, l1, l22)
        }
    }
}

ghost
decreases
requires ctx.CanFlow(t, label.Readers(set[Id]{ id }), label.Public())
ensures  corruptedId in t.getCorruptIds() && id.Covers(corruptedId)
func (ctx DefaultLabelingContext) CanFlowToPublicImpliesCorruption(t tr.TraceEntry, id Id) (corruptedId Id) {
    assert exists corruptedId Id :: corruptedId in t.getCorruptIds() && id.Covers(corruptedId)
    // get witness
    corruptedId := arb.GetArbId()
    assume corruptedId in t.getCorruptIds() && id.Covers(corruptedId)
}

ghost
decreases
requires ids1 subset ids2 || includesIds(ids2, ids1)
requires tr.containsCorruptId(corruptIds, ids1)
ensures  tr.containsCorruptId(corruptIds, ids2)
func (ctx DefaultLabelingContext) containsCorruptIdMonotonic(corruptIds, ids1, ids2 set[Id]) {
    assert exists corruptedId Id :: { tr.containsId(ids1, corruptedId) } corruptedId in corruptIds && tr.containsId(ids1, corruptedId)
    // get witness:
    corruptedId := arb.GetArbId()
    assume corruptedId in corruptIds && tr.containsId(ids1, corruptedId)
    if includesIds(ids2, ids1) {
        ctx.containsIdTransitive(ids1, ids2, corruptedId)
    }
    // the following assert stmt is necessary:
    assert tr.containsId(ids2, corruptedId)
}

ghost
decreases
requires corruptIds1 subset corruptIds2
requires tr.containsCorruptId(corruptIds1, ids)
ensures  tr.containsCorruptId(corruptIds2, ids)
func (ctx DefaultLabelingContext) containsCorruptIdMonotonic2(corruptIds1, corruptIds2, ids set[Id]) {
    assert exists corruptedId Id :: { tr.containsId(ids, corruptedId) } corruptedId in corruptIds1 && tr.containsId(ids, corruptedId)
    // get witness:
    corruptedId := arb.GetArbId()
    assume corruptedId in corruptIds1 && tr.containsId(ids, corruptedId)
    assert corruptedId in corruptIds2
}

ghost
decreases
requires tr.containsCorruptId(corruptIds, ids1 union ids2)
ensures  tr.containsCorruptId(corruptIds, ids1) || tr.containsCorruptId(corruptIds, ids2)
func (ctx DefaultLabelingContext) containsCorruptIdSplit(corruptIds set[Id], ids1, ids2 set[Id]) {
    ids := ids1 union ids2
    assert exists corruptedId Id :: { tr.containsId(ids, corruptedId) } corruptedId in corruptIds && tr.containsId(ids, corruptedId)
    // get witness:
    corruptedId := arb.GetArbId()
    assume corruptedId in corruptIds && tr.containsId(ids, corruptedId)
    ctx.containsIdSplit(ids1, ids2, corruptedId)
}

ghost
decreases
requires tr.containsCorruptId(corruptIds, ids1) || tr.containsCorruptId(corruptIds, ids2)
ensures  tr.containsCorruptId(corruptIds, ids1 union ids2)
func (ctx DefaultLabelingContext) containsCorruptIdUnion(corruptIds set[Id], ids1, ids2 set[Id]) {
    ids := ids1 union ids2
    if tr.containsCorruptId(corruptIds, ids1) {
        ctx.containsCorruptIdMonotonic(corruptIds, ids1, ids)
    } else if tr.containsCorruptId(corruptIds, ids2) {
        ctx.containsCorruptIdMonotonic(corruptIds, ids2, ids)
    }
}

ghost
decreases
ensures  (!tr.containsCorruptId(corruptIds, ids1) && !tr.containsCorruptId(corruptIds, ids2)) == !tr.containsCorruptId(corruptIds, ids1 union ids2)
func (ctx DefaultLabelingContext) containsCorruptIdNotUnion(corruptIds set[Id], ids1, ids2 set[Id]) {
    ids := ids1 union ids2
    if !tr.containsCorruptId(corruptIds, ids1) &&
        !tr.containsCorruptId(corruptIds, ids2) {
        // we prove it by contradiction:
        if tr.containsCorruptId(corruptIds, ids) {
            ctx.containsCorruptIdSplit(corruptIds, ids1, ids2)
        }
    }
    if !tr.containsCorruptId(corruptIds, ids1 union ids2) {
        // we prove it by contradiction:
        if tr.containsCorruptId(corruptIds, ids1) ||
            tr.containsCorruptId(corruptIds, ids2) {
            ctx.containsCorruptIdUnion(corruptIds, ids1, ids2)
        }
    }
}

ghost
decreases
requires tr.containsId(ids1, corruptedId) && includesIds(ids2, ids1)
ensures  tr.containsId(ids2, corruptedId)
func (ctx DefaultLabelingContext) containsIdTransitive(ids1, ids2 set[Id], corruptedId Id) {
    // apply `containsId(ids1, corruptedId)`:
    assert exists id1 Id :: { id1.Covers(corruptedId) } id1 in ids1 && id1.Covers(corruptedId)
    // get witness:
    id1 := arb.GetArbId()
    assume id1 in ids1 && id1.Covers(corruptedId)
    
    // apply `includesIds(ids2, ids1)`:
    assert forall id Id :: id in ids1 ==> tr.containsId(ids2, id)
    assert tr.containsId(ids2, id1)

    // apply `containsId(ids2, id1)`:
    assert exists id Id :: id in ids2 && id.Covers(id1)
    // get witness:
    idX := arb.GetArbId()
    assume idX in ids2 && idX.Covers(id1)

    idX.CoversTransitive(id1, corruptedId)
    assert exists id Id :: { id.Covers(corruptedId) } id in ids2 && id.Covers(corruptedId)
}

ghost
decreases
requires tr.containsId(ids1 union ids2, corruptedId)
ensures  tr.containsId(ids1, corruptedId) || tr.containsId(ids2, corruptedId)
func (ctx DefaultLabelingContext) containsIdSplit(ids1, ids2 set[Id], corruptedId Id) {
    // no body needed
}

ghost
/**
 * checks whether every id in `ids` is contained in `haystack` while taking their
 * coverings into account.
 * This is similar to `containsCorruptId` except that a forall instead of existential
 * quantifier is used for every ID contained in the first parameter.
 */
pure func includesIds(haystack, ids set[Id]) bool {
    return forall id Id :: { tr.containsId(haystack, id) } id in ids ==> tr.containsId(haystack, id)
}

ghost
ensures includesIds(ids, ids)
func (ctx DefaultLabelingContext) includesIdsReflexive(ids set[Id]) {
    arbId := arb.GetArbId()
    if arbId in ids {
        arbId.CoversReflexive()
    }
    // we have shown it for an arbitrary `arbId` and can thus perform forall introduction:
    assert arbId in ids ==> tr.containsId(ids, arbId)
    assume forall id Id :: { tr.containsId(ids, id) } id in ids ==> tr.containsId(ids, id)
}

ghost
requires includesIds(ids1, ids2) && includesIds(ids2, ids3)
ensures  includesIds(ids1, ids3)
func (ctx DefaultLabelingContext) includesIdsTransitive(ids1, ids2, ids3 set[Id]) {
    assert forall id Id :: { tr.containsId(ids1, id) } id in ids2 ==> tr.containsId(ids1, id)
    assert forall id Id :: { tr.containsId(ids2, id) } id in ids3 ==> tr.containsId(ids2, id)
    
    arbId := arb.GetArbId()
    if arbId in ids3 {
        // follows from `includesIds(ids2, ids3)`:
        assert tr.containsId(ids2, arbId)
        // use additionally the fact that `includesIds(ids1, ids2)`:
        ctx.containsIdTransitive(ids2, ids1, arbId)
    }
    assert arbId in ids3 ==> tr.containsId(ids1, arbId)
    // we can do a forall introduction as `arbId` is unconstraint:
    assume forall id Id :: { tr.containsId(ids1, id) } id in ids3 ==> tr.containsId(ids1, id)
}

ghost
requires ids2 subset ids1
ensures  includesIds(ids1, ids2)
func (ctx DefaultLabelingContext) includesIdsSubset(ids1, ids2 set[Id]) {
    arbId := arb.GetArbId()
    if arbId in ids2 {
        // apply `ids2 subset ids1`:
        assert arbId in ids1
        arbId.CoversReflexive()
        // `arbId` is itself the witness for `containsId(ids1, arbId)`:
        assert tr.containsId(ids1, arbId)
    }
    assert arbId in ids2 ==> tr.containsId(ids1, arbId)
    // perform a forall introduction since `arbId` is unconstraint:
    assume forall id Id :: { tr.containsId(ids1, id) } id in ids2 ==> tr.containsId(ids1, id)
}

ghost
pure func (ctx DefaultLabelingContext) GetSkLabel(pk tm.Term) label.SecrecyLabel {
    return (pk.IsPk()) ?
        ctx.GetLabel(tm.getSk(pk)) :
        label.Public()
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) IsSecretKey(t tr.TraceEntry, owner Id, sk tm.Term, keyType KeyType, usage string) bool {
    // TODO case switch over all key types. We assume now that there is only KeyType `PKE`
    return (keyType == KeyTypePke() ==> ctx.IsPrivateDecKey(t, owner, sk, usage)) &&
        (keyType == KeyTypeDHPk() ==> ctx.IsPrivateDhKey(t, owner, sk, usage))
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsSecretKey(t1, owner, sk, keyType, usage)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsSecretKey(t2, owner, sk, keyType, usage)
func (ctx DefaultLabelingContext) IsSecretKeyMonotonic(t1, t2 tr.TraceEntry, owner Id, sk tm.Term, keyType KeyType, usage string, p perm) bool {
    if keyType == KeyTypePke() {
        ctx.IsPrivateDecKeyMonotonic(t1, t2, owner, sk, usage, p)
    } else if keyType == KeyTypeDHPk() {
        ctx.IsPrivateDhKeyMonotonic(t1, t2, owner, sk, usage, p)
    }
}

ghost
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.IsSecretKey(t, owner, sk, keyType, usage)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsLabeled(t, sk, label.Readers(set[Id]{ owner }))
func (ctx DefaultLabelingContext) IsSecretKeyLemma(t tr.TraceEntry, owner Id, sk tm.Term, keyType KeyType, usage string, p perm) {
    // the following assert stmt is needed for triggering reasons:
    assert getKeyTypeType(keyType) == 0 || getKeyTypeType(keyType) == 1
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) IsPublicKey(t tr.TraceEntry, skOwner Id, pk, sk tm.Term, keyType KeyType, usage string) bool {
    // TODO case switch over all key types. We assume now that there is only KeyType `PKE`
    return (keyType == KeyTypePke() ==> ctx.IsPublicEncKey(t, skOwner, pk, sk, usage)) &&
        (keyType == KeyTypeDHPk() ==> ctx.IsPublicDhPk(t, skOwner, pk, sk, usage))
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsPublicKey(t1, skOwner, pk, sk, keyType, usage)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsPublicKey(t2, skOwner, pk, sk, keyType, usage)
func (ctx DefaultLabelingContext) IsPublicKeyMonotonic(t1, t2 tr.TraceEntry, skOwner Id, pk, sk tm.Term, keyType KeyType, usage string, p perm) {
    if keyType == KeyTypePke() {
        ctx.IsPublicEncKeyMonotonic(t1, t2, skOwner, pk, sk, usage, p)
    } else if keyType == KeyTypeDHPk() {
        ctx.IsPublicDhPkMonotonic(t1, t2, skOwner, pk, sk, usage, p)
    }
}

ghost
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.IsPublicKey(t, skOwner, pk, sk, keyType, usage)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsLabeled(t, sk, label.Readers(set[Id]{ skOwner }))
func (ctx DefaultLabelingContext) IsPublicKeyLemma(t tr.TraceEntry, skOwner Id, pk, sk tm.Term, keyType KeyType, usage string, p perm) {
    // the following assert stmt is needed for triggering reasons:
    assert getKeyTypeType(keyType) == 0 || getKeyTypeType(keyType) == 1
    if keyType == KeyTypePke() {
        assert ctx.IsSecret(t, sk, label.Readers(set[Id]{ skOwner }), u.PkeKey(usage))
    } else if keyType == KeyTypeDHPk() {
        assert ctx.IsSecret(t, sk, label.Readers(set[Id]{ skOwner }), u.DhKey(usage))
    }
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) IsPublicKeyExistential(t tr.TraceEntry, skOwner Id, pk tm.Term, keyType KeyType, usage string) bool {
    return (keyType == KeyTypePke() ==> exists sk tm.Term :: { ctx.IsPublicEncKey(t, skOwner, pk, sk, usage) } ctx.IsPublicEncKey(t, skOwner, pk, sk, usage)) &&
        (keyType == KeyTypeDHPk() ==> ctx.IsPublicDhPkExistential(t, skOwner, pk, usage))
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsPublicKeyExistential(t1, skOwner, pk, keyType, usage)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsPublicKeyExistential(t2, skOwner, pk, keyType, usage)
func (ctx DefaultLabelingContext) IsPublicKeyExistentialMonotonic(t1, t2 tr.TraceEntry, skOwner Id, pk tm.Term, keyType KeyType, usage string, p perm) {
    skWitness := arb.GetArbTerm()
	if keyType == KeyTypePke() {
		assert exists sk tm.Term :: { ctx.IsPublicEncKey(t1, skOwner, pk, sk, usage) } ctx.IsPublicEncKey(t1, skOwner, pk, sk, usage)
		// get witness
		assume ctx.IsPublicEncKey(t1, skOwner, pk, skWitness, usage)
	} else if keyType == KeyTypeDHPk() {
		assert exists sk tm.Term :: { ctx.IsPublicDhPk(t1, skOwner, pk, sk, usage) } ctx.IsPublicDhPk(t1, skOwner, pk, sk, usage)
		// get witness
		assume ctx.IsPublicDhPk(t1, skOwner, pk, skWitness, usage)
	}
	ctx.IsPublicKeyMonotonic(t1, t2, skOwner, pk, skWitness, keyType, usage, p)
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) IsPrivateDecKey(t tr.TraceEntry, owner Id, sk tm.Term, usage string) bool {
    return sk == tm.random(tm.gamma(sk), label.Readers(set[Id]{ owner }), u.PkeKey(usage)) &&
        ctx.IsSecret(t, sk, label.Readers(set[Id]{ owner }), u.PkeKey(usage))
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsPrivateDecKey(t1, owner, sk, usage)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsPrivateDecKey(t2, owner, sk, usage)
func (ctx DefaultLabelingContext) IsPrivateDecKeyMonotonic(t1, t2 tr.TraceEntry, owner Id, sk tm.Term, usage string, p perm) {
    ctx.IsSecretMonotonic(t1, t2, sk, label.Readers(set[Id]{ owner }), u.PkeKey(usage), p)
}

ghost
requires acc(ctx.Pred(), _)
// sk is the witness
pure func (ctx DefaultLabelingContext) IsPublicEncKey(t tr.TraceEntry, skOwner Id, pk, sk tm.Term, usage string) bool {
    return ctx.IsPublishable(t, pk) &&
        ctx.IsPrivateDecKey(t, skOwner, sk, usage) &&
        pk == tm.createPk(sk)
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsPublicEncKey(t1, skOwner, pk ,sk, usage)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsPublicEncKey(t2, skOwner, pk ,sk, usage)
func (ctx DefaultLabelingContext) IsPublicEncKeyMonotonic(t1, t2 tr.TraceEntry, skOwner Id, pk, sk tm.Term, usage string, p perm) {
    ctx.IsPublishableMonotonic(t1, t2, pk, p)
    ctx.IsPrivateDecKeyMonotonic(t1, t2, skOwner, sk, usage, p)
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) IsPublicEncKeyExistential(t tr.TraceEntry, pk tm.Term, l label.SecrecyLabel, usage string) bool {
    return ctx.IsPublishable(t, pk) &&
        pk.IsPk() &&
        ctx.IsSecret(t, tm.getSk(pk), l, u.PkeKey(usage))
}

ghost
requires acc(ctx.Pred(), _)
// sk is the witness
pure func (ctx DefaultLabelingContext) IsPrivateDhKey(t tr.TraceEntry, owner Id, sk tm.Term, usage string) bool {
    return sk.IsRandom() &&
        ctx.IsSecret(t, sk, label.Readers(set[Id]{ owner }), u.DhKey(usage))
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsPrivateDhKey(t1, owner, sk, usage)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsPrivateDhKey(t2, owner, sk, usage)
func (ctx DefaultLabelingContext) IsPrivateDhKeyMonotonic(t1, t2 tr.TraceEntry, owner Id, sk tm.Term, usage string, p perm) {
    ctx.IsSecretMonotonic(t1, t2, sk, label.Readers(set[Id]{ owner }), u.DhKey(usage), p)
}

ghost
requires acc(ctx.Pred(), _)
// sk is the witness
pure func (ctx DefaultLabelingContext) IsPublicDhPk(t tr.TraceEntry, skOwner Id, pk, sk tm.Term, usage string) bool {
    return ctx.IsPublishable(t, pk) &&
        pk == tm.exp(tm.generator(), sk) &&
        ctx.IsPrivateDhKey(t, skOwner, sk, usage)
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires t1.isSuffix(t2)
requires ctx.IsPublicDhPk(t1, skOwner, pk, sk, usage)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsPublicDhPk(t2, skOwner, pk, sk, usage)
func (ctx DefaultLabelingContext) IsPublicDhPkMonotonic(t1, t2 tr.TraceEntry, skOwner Id, pk, sk tm.Term, usage string, p perm) {
    ctx.IsPublishableMonotonic(t1, t2, pk, p / 2)
    ctx.IsPrivateDhKeyMonotonic(t1, t2, skOwner, sk, usage, p / 2)
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) IsPublicDhPkExistential(t tr.TraceEntry, skOwner Id, pk tm.Term, usage string) bool {
    return exists sk tm.Term :: { ctx.IsPublicDhPk(t, skOwner, pk, sk, usage) } ctx.IsPublicDhPk(t, skOwner, pk, sk, usage)
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.IsMsg(t, term, l1)
requires ctx.CanFlow(t, l1, l2)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsMsg(t, term, l2)
func (ctx DefaultLabelingContext) Restrict(t tr.TraceEntry, term tm.Term, l1, l2 label.SecrecyLabel, p perm) {
    ctx.CanFlowTransitive(t, ctx.GetLabel(term), l1, l2)
}

pred (ctx DefaultLabelingContext) NonceIsUnique(nonce tm.Term) {
    acc(ctx.getNonceIsUniquePointer(nonce))
}

pred (ctx DefaultLabelingContext) NonceForEventIsUnique(nonce tm.Term, eventType ev.EventType) {
    acc(ctx.getNonceForEventIsUniquePointer(nonce, eventType))
}

// each nonce term is (injectively) mapped to a heap location for which write access
// is obtained as part of the nonce generation algorithm.
// Pairwise disjointness of nonces / their uniqueness directly follows from this property
// as otherwise the `NonceIsUnique` resource would be stored twice on the trace which immediately
// results in a contradiction when unfolding the predicate instances
type Void int // note that `struct{}` results in Gobra not generating the expected heap permissions
ghost
pure func (ctx DefaultLabelingContext) getNonceIsUniquePointer(nonce tm.Term) *Void

ghost
pure func (ctx DefaultLabelingContext) getNonceForEventIsUniquePointer(nonce tm.Term, eventType ev.EventType) *Void

ghost
decreases
requires acc(ctx.Pred(), _)
requires acc(ctx.NonceForEventIsUnique(nonce, eventType), 2/1)
ensures  false
func (ctx DefaultLabelingContext) NonceForEventContradiction(nonce tm.Term, eventType ev.EventType) {
    unfold acc(ctx.NonceForEventIsUnique(nonce, eventType), 2/1)
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) CanEncrypt(t tr.TraceEntry, msg, pk tm.Term) bool {
    return ctx.IsPublishable(t, pk) &&
        ctx.IsPkeKey(tm.getSk(pk)) &&
        ctx.IsMsg(t, msg, ctx.GetSkLabel(pk)) &&
        (forall usageString string :: { ctx.usage.PkePred(t, usageString, msg, pk) } ctx.IsPublicEncKeyExistential(t, pk, ctx.GetSkLabel(pk), usageString) ==>
            unfolding acc(ctx.Pred(), _) in
                ctx.usage.PkePred(t, usageString, msg, pk))
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.CanEncrypt(t, msg, pk) || (ctx.IsPublishable(t, msg) && ctx.IsPublishable(t, pk))
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsPublishable(t, tm.encrypt(msg, pk))
func (ctx DefaultLabelingContext) CiphertextIsPublishable(t tr.TraceEntry, msg, pk tm.Term, p perm) {
    msgLabel := ctx.GetLabel(msg)
    if ctx.IsPublishable(t, msg) {
        ctx.FlowsToPublicCanFlow(t, msgLabel, ctx.GetSkLabel(pk))
    }
    // the following assert stmt is necessary:
	assert ctx.IsValidEncrypt(t, pk, msg, msgLabel)
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) CanDecrypt(t tr.TraceEntry, ciphertext, sk tm.Term, skOwner Id) bool {
    return ctx.IsPublishable(t, ciphertext) &&
        (ctx.IsPublishable(t, sk) || exists usageString string :: { ctx.IsPrivateDecKey(t, skOwner, sk, usageString) } ctx.IsPrivateDecKey(t, skOwner, sk, usageString))
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) WasDecrypted(t tr.TraceEntry, msg, sk tm.Term, skOwner Id) bool {
    return ctx.IsLabeled(t, sk, label.Readers(set[Id]{ skOwner })) ==>
        (ctx.IsMsg(t, msg, label.Readers(set[Id]{ skOwner })) &&
        (forall usageString string :: { ctx.IsPrivateDecKey(t, skOwner, sk, usageString) } ctx.IsPrivateDecKey(t, skOwner, sk, usageString) ==>
            ctx.IsPublishable(t, msg) || unfolding acc(ctx.Pred(), _) in ctx.usage.PkePred(t, usageString, msg, tm.createPk(sk))))
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.IsPublishable(t, ciphertext) && ctx.IsPublishable(t, sk)
ensures  acc(ctx.Pred(), p)
ensures  ctx.CanDecrypt(t, ciphertext, sk, skOwner)
func (ctx DefaultLabelingContext) CanDecryptWithPublicSk(t tr.TraceEntry, ciphertext, sk tm.Term, skOwner Id, p perm) {
    // no body needed
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.CanDecrypt(t, tm.encrypt(msg, tm.createPk(sk)), sk, skOwner)
ensures  acc(ctx.Pred(), p)
ensures  ctx.WasDecrypted(t, msg, sk, skOwner)
func (ctx DefaultLabelingContext) DecryptSatisfiesInvariant(t tr.TraceEntry, msg, sk tm.Term, skOwner Id, p perm) {
    pk := tm.createPk(sk)
	plaintextLabel := ctx.GetLabel(msg)
	skLabel := ctx.GetLabel(sk)
	// the following assertion is necessary to derive that `ctx.IsMsg(t, msg, skLabel)`
	assert ctx.IsValidEncrypt(t, pk, msg, plaintextLabel)
	if (ctx.CanFlow(t, plaintextLabel, label.Public())) {
		ctx.CanFlowTransitive(t, plaintextLabel, label.Public(), skLabel)
	}
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.IsPublishable(t, tm.encrypt(msg, tm.createPk(sk))) && ctx.IsPublishable(t, sk)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsPublishable(t, msg)
func (ctx DefaultLabelingContext) PlaintextIsPublishableForPublicSk(t tr.TraceEntry, msg, sk tm.Term, skOwner Id, p perm) {
    pk := tm.createPk(sk)
	plaintextLabel := ctx.GetLabel(msg)
	skLabel := ctx.GetLabel(sk)
	// the following assertion is necessary to derive that `ctx.IsMsg(t, msg, skLabel)`
	assert ctx.IsValidEncrypt(t, pk, msg, plaintextLabel)
    ctx.CanFlowTransitive(t, plaintextLabel, skLabel, label.Public())
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) CanAeadEncrypt(t tr.TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel) bool {
    return ctx.IsLabeledRelaxed(t, key, keyL) &&
        (ctx.IsPublishable(t, key) || exists usageString string :: ctx.IsAeadKey(t, key, keyL, usageString)) &&
        ctx.IsPublishable(t, nonce) &&
        ctx.IsMsg(t, msg, keyL) &&
        ctx.IsPublishable(t, ad) &&
        (forall usageString string :: ctx.IsAeadKey(t, key, keyL, usageString) ==> unfolding acc(ctx.Pred(), _) in ctx.usage.AeadPred(t, usageString, key, nonce, msg, ad))
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.CanAeadEncrypt(t, key, nonce, msg, ad, keyL) || (ctx.IsPublishable(t, key) && ctx.IsPublishable(t, nonce) && ctx.IsPublishable(t, msg) && ctx.IsPublishable(t, ad))
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsPublishable(t, tm.aead(key, nonce, msg, ad))
func (ctx DefaultLabelingContext) AeadCiphertextIsPublishable(t tr.TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel, p perm) {
    msgL := ctx.GetLabel(msg)
    if ctx.IsPublishable(t, key) {
        if !ctx.IsPublishable(t, msg) {
            ctx.CanFlowTransitive(t, keyL, ctx.GetLabel(key), label.Public())
            ctx.CanFlowTransitive(t, msgL, keyL, label.Public())
        }
    } else {
        // the following assert stmt would not be necessary:
        usageCtx := ctx.GetUsage(key)
        unfold acc(ctx.Pred(), p)
        assert ctx.usage.AeadPred(t, u.GetUsageString(get(usageCtx)), key, nonce, msg, ad)
        fold acc(ctx.Pred(), p)
        ctx.CanFlowTransitive(t, msgL, keyL, ctx.GetLabel(key))
    }
    // the following assert stmt is necessary:
	assert ctx.IsValidAead(t, key, nonce, msg, msgL, ad)
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) CanAeadDecrypt(t tr.TraceEntry, key, nonce, ciphertext, ad tm.Term, keyL label.SecrecyLabel) bool {
    return true
}

ghost
requires acc(ctx.Pred(), _)
pure func (ctx DefaultLabelingContext) WasAeadDecrypted(t tr.TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel) bool {
    return ((ctx.IsPublishable(t, key) || exists usageString string :: ctx.IsAeadKey(t, key, keyL, usageString)) &&
        ctx.IsPublishable(t, nonce) &&
        ctx.IsPublishable(t, tm.aead(key, nonce, msg, ad)) &&
        ctx.IsPublishable(t, ad)) ==>
            (ctx.IsMsg(t, msg, ctx.GetLabel(key)) &&
            (forall usageString string :: { ctx.IsAeadKey(t, key, keyL, usageString) } ctx.IsAeadKey(t, key, keyL, usageString) ==>
                // either the attacker has applied AEAD encryption or AeadPred holds
                // in the first case, this requires that all components are known by the attacker (i.e. key, nonce, msg, and ad)
                (ctx.IsPublishable(t, key) && ctx.IsPublishable(t, msg)) || unfolding acc(ctx.Pred(), _) in ctx.usage.AeadPred(t, usageString, key, nonce, msg, ad)))
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.IsPublishable(t, key) && ctx.IsPublishable(t, nonce) && ctx.IsPublishable(t, ciphertext) && ctx.IsPublishable(t, ad)
ensures  acc(ctx.Pred(), p)
ensures  ctx.CanAeadDecrypt(t, key, nonce, ciphertext, ad, keyL)
func (ctx DefaultLabelingContext) CanAeadDecryptWithPublishableKey(t tr.TraceEntry, key, nonce, ciphertext, ad tm.Term, keyL label.SecrecyLabel, p perm) {
    // no body needed
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.CanAeadDecrypt(t, key, nonce, tm.aead(key, nonce, msg, ad), ad, keyL)
ensures  acc(ctx.Pred(), p)
ensures  ctx.WasAeadDecrypted(t, key, nonce, msg, ad, keyL)
func (ctx DefaultLabelingContext) AeadDecryptSatisfiesInvariant(t tr.TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel, p perm) {
    if ((ctx.IsPublishable(t, key) || exists usageString string :: ctx.IsAeadKey(t, key, keyL, usageString)) &&
        ctx.IsPublishable(t, nonce) &&
        ctx.IsPublishable(t, tm.aead(key, nonce, msg, ad)) &&
        ctx.IsPublishable(t, ad)) {
        msgL := ctx.GetLabel(msg)
	    // the following assertion is necessary to derive that `ctx.IsMsg(t, msg, keyL)`
	    assert ctx.IsValidAead(t, key, nonce, msg, msgL, ad)
	    if (ctx.CanFlow(t, msgL, label.Public())) {
	        ctx.CanFlowTransitive(t, msgL, label.Public(), ctx.GetLabel(key))
	    }
    }
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.IsPublishable(t, tm.aead(key, nonce, msg, ad)) && ctx.IsPublishable(t, key) && ctx.IsPublishable(t, nonce) && ctx.IsPublishable(t, ad)
ensures  acc(ctx.Pred(), p)
ensures  ctx.IsPublishable(t, msg)
func (ctx DefaultLabelingContext) PlaintextIsPublishableForPublishableKey(t tr.TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel, p perm) {
    if ((ctx.IsPublishable(t, key) || exists usageString string :: ctx.IsAeadKey(t, key, keyL, usageString)) &&
        ctx.IsPublishable(t, nonce) &&
        ctx.IsPublishable(t, tm.aead(key, nonce, msg, ad)) &&
        ctx.IsPublishable(t, ad)) {
        msgL := ctx.GetLabel(msg)
	    // the following assertion is necessary to derive that `ctx.IsMsg(t, msg, keyL)`
	    assert ctx.IsValidAead(t, key, nonce, msg, msgL, ad)
	    if !ctx.CanFlow(t, msgL, label.Public()) {
            ctx.CanFlowTransitive(t, msgL, ctx.GetLabel(key), label.Public())
        }
    }
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.IsLabeled(t, term, l)
requires l.IsReaders()
requires !tr.containsCorruptId(t.getCorruptIds(), label.GetReaders(l))
ensures  acc(ctx.Pred(), p)
ensures  !ctx.IsPublishable(t, term)
func (ctx DefaultLabelingContext) PublishableRequiresCorruption(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel, p perm) {
    // no body needed
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.IsLabeledRelaxed(t, term, l)
requires l.IsReaders()
requires !tr.containsCorruptId(t.getCorruptIds(), label.GetReaders(l))
ensures  acc(ctx.Pred(), p)
ensures  !ctx.IsPublishable(t, term)
/**
  * weakened version of `PublishableRequiresCorruption`: instead of requiring `term` being
  * labeled with a `Readers` label, we can permit any label to which `Readers` (i.e. `l`) flows to
  */
func (ctx DefaultLabelingContext) PublishableRequiresCorruptionWeakened(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel, p perm) {
    // proof by contradiction:
    // we assume that `l` flows to public and show then that term's actual label would flow
    // to public as well, which contradicts the precondition that `l` does not
    // contain any corrupted IDs:
    termL := ctx.GetLabel(term)
    if ctx.CanFlow(t, termL, label.Public()) {
        ctx.CanFlowTransitive(t, l, termL, label.Public())
        // this is a contradiction as l would flow to public!
    }
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.IsLabeledRelaxed(t, term, l)
requires l.IsReaders()
requires ctx.IsPublishable(t, term)
ensures  acc(ctx.Pred(), p)
ensures  tr.containsCorruptId(t.getCorruptIds(), label.GetReaders(l))
ensures  corruptedId in t.getCorruptIds()
ensures  id in label.GetReaders(l) && id.Covers(corruptedId)
func (ctx DefaultLabelingContext) PublishableImpliesCorruption(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel, p perm) (corruptedId, id Id) {
    termL := ctx.GetLabel(term)
    readers := label.GetReaders(l)
    corruptIds := t.getCorruptIds()
    ctx.CanFlowTransitive(t, l, termL, label.Public())
    // apply `containsCorruptId(corruptIds, readers)`:
    assert exists corruptedId Id :: { tr.containsId(readers, corruptedId) } corruptedId in corruptIds && tr.containsId(readers, corruptedId)
    // get witness
    corruptedId = arb.GetArbId()
    assume corruptedId in corruptIds && tr.containsId(readers, corruptedId)
    // apply `containsId(readers, corruptedId)`:
    assert exists id Id :: { id.Covers(corruptedId) } id in readers && id.Covers(corruptedId)
    // get witness
    id = arb.GetArbId()
    assume id in readers && id.Covers(corruptedId)
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires ctx.IsMsg(t, term, l)
requires l.IsReaders()
requires !ctx.IsPublishable(t, term)
ensures  acc(ctx.Pred(), p)
ensures  !tr.containsCorruptId(t.getCorruptIds(), label.GetReaders(l))
func (ctx DefaultLabelingContext) NotPublishableImpliesNoCorruption(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel, p perm) {
    if ctx.CanFlow(t, l, label.Public()) {
        // derive a contradiction:
        ctx.CanFlowTransitive(t, ctx.GetLabel(term), l, label.Public())
    }
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires acc(ctx.Pred(), p)
requires l1.IsReaders() && l2.IsReaders()
requires ctx.IsLabeledRelaxed(t, term, label.Join(l1, l2))
ensures  acc(ctx.Pred(), p)
ensures  optCorruptedId == none[Id] ?
    !ctx.IsPublishable(t, term) :
    ((tr.containsId(label.GetReaders(l1), get(optCorruptedId)) || tr.containsId(label.GetReaders(l2), get(optCorruptedId))) &&
        get(optCorruptedId) in t.getCorruptIds() &&
        tr.containsCorruptId(t.getCorruptIds(), label.GetReaders(l1) union label.GetReaders(l2)))
func (ctx DefaultLabelingContext) RelaxedLabelingImpliesNotPublishableOrCorruption(t tr.TraceEntry, term tm.Term, l1, l2 label.SecrecyLabel, p perm) (optCorruptedId option[Id]) {
    termL := ctx.GetLabel(term)
    if ctx.IsPublishable(t, term) {
        joinL := label.Join(l1, l2)
        ctx.CanFlowTransitive(t, joinL, termL, label.Public())
        // the following assert stmt is necessary:
        assert ctx.CanFlow(t, l1, label.Public()) || ctx.CanFlow(t, l2, label.Public())
        if ctx.CanFlow(t, l1, label.Public()) {
            assert exists corruptedId Id :: { tr.containsId(label.GetReaders(l1), corruptedId) } corruptedId in t.getCorruptIds() && tr.containsId(label.GetReaders(l1), corruptedId)
            corruptedId := arb.GetArbId()
            assume corruptedId in t.getCorruptIds() && tr.containsId(label.GetReaders(l1), corruptedId)
            optCorruptedId = some(corruptedId)
        } else {
            assert exists corruptedId Id :: { tr.containsId(label.GetReaders(l2), corruptedId) } corruptedId in t.getCorruptIds() && tr.containsId(label.GetReaders(l2), corruptedId)
            corruptedId := arb.GetArbId()
            assume corruptedId in t.getCorruptIds() && tr.containsId(label.GetReaders(l2), corruptedId)
            optCorruptedId = some(corruptedId)
        }
        ctx.containsCorruptIdNotUnion(t.getCorruptIds(), label.GetReaders(l1), label.GetReaders(l2))
    } else {
        optCorruptedId = none[Id]
    }
}
