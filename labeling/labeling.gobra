package labeling

import ev "gitlab.inf.ethz.ch/arquintl/prototrace/event"
import "gitlab.inf.ethz.ch/arquintl/prototrace/label"
import p "gitlab.inf.ethz.ch/arquintl/prototrace/principal"
import tm "gitlab.inf.ethz.ch/arquintl/prototrace/term"
import tr "gitlab.inf.ethz.ch/arquintl/prototrace/trace"
import u "gitlab.inf.ethz.ch/arquintl/prototrace/usage"
import . "gitlab.inf.ethz.ch/arquintl/prototrace/usagecontext"

type DefaultLabelingContext struct {
    usage UsageContext
}
DefaultLabelingContext implements tr.LabelingContext

// TODO make ghost
pure func GetDefaultLabelingContext(usage UsageContext) (res DefaultLabelingContext) {
    return DefaultLabelingContext{ usage }
}

ghost
pure func (ctx DefaultLabelingContext) IsValid(t tr.TraceEntry, term tm.Term) bool {
    return (term.IsInteger64() ==> true) &&
        (term.IsInteger32() ==> true) &&
        (term.IsString() ==> true) &&
        (term.IsZeroString() ==> true) &&
        (term.IsPk() ==> ctx.IsValid(t, tm.getSk(term))) &&
        (term.IsEncrypt() ==>
            ctx.IsValidEncrypt(t, tm.getPk(term), tm.getPlaintext(term), ctx.GetLabel(tm.getPlaintext(term)))) &&
        (term.IsRandom() ==>
            // (tm.getRandomTrace(term)).traceLen() <= t.traceLen() &&
            // TODO isn't the following expression trivially true?
            // (tm.getRandomTrace(term)).isNonceAt(term) &&
            // (tm.getRandomTrace(term)).isNonce() && tr.getNonce(tm.getRandomTrace(term)) == tm.gamma(term)) &&
            // this is equivalent to saying that `term` occurs in a nonce entry on the trace because
            // the random term determines its label and usage. However, `nonceOccurs` saves us from
            // writing yet another function to simply state that `term` is on the trace
            // t.nonceOccurs(term, tm.getRandomLabel(term), tm.getRandomUsage(term))) &&
            t.OnlyNonceOccurs(term)) &&
        (term.IsTuple2() ==> ctx.IsValid(t, tm.getFirst(term)) && ctx.IsValid(t, tm.getSecond(term))) &&
        (term.IsTuple3() ==> ctx.IsValid(t, tm.getFirst(term)) && ctx.IsValid(t, tm.getSecond(term)) && ctx.IsValid(t, tm.getThird(term))) &&
        (term.IsTuple4() ==> ctx.IsValid(t, tm.getFirst(term)) && ctx.IsValid(t, tm.getSecond(term)) && ctx.IsValid(t, tm.getThird(term)) && ctx.IsValid(t, tm.getForth(term)))
}

ghost
requires ctx.GetLabel(plaintext) == plaintextLabel
pure func (ctx DefaultLabelingContext) IsValidEncrypt(t tr.TraceEntry, pk, plaintext tm.Term, plaintextLabel label.SecrecyLabel) bool {
    return ctx.IsValid(t, pk) &&
        ctx.IsValid(t, plaintext) &&
        // message has to flow to secrecy label of secret key
        ctx.CanFlow(t, plaintextLabel, ctx.GetSkLabel(pk)) &&
        (
            // either the plaintext is public ...
            ctx.CanFlow(t, plaintextLabel, label.Public()) ||
            // ... or pkePred holds
            (
                pk.IsPk() &&
                ctx.IsPkeKey(tm.getSk(pk)) &&
                ctx.usage.PkePred(t, u.GetUsageString(u.getUsage(ctx.GetUsage(tm.getSk(pk)))), plaintext, pk)))
}

ghost
decreases _ // TODO decreases because we apply an term ADT constructor in each recursive call
requires t1.isSuffix(t2)
requires ctx.IsValid(t1, term)
ensures  ctx.IsValid(t2, term)
func (ctx DefaultLabelingContext) IsValidMonotonic(t1, t2 tr.TraceEntry, term tm.Term) {
    if (term.IsRandom()) {
        t1.OnlyNonceOccursMonotonic(t2, term)
    } else if (term.IsEncrypt()) {
        pk := tm.getPk(term)
        plaintext := tm.getPlaintext(term)
        ctx.IsValidEncryptMonotonic(t1, t2, pk, plaintext, ctx.GetLabel(plaintext))
    } else if (term.IsPk()) {
        ctx.IsValidMonotonic(t1, t2, tm.getSk(term))
    } else if (term.IsTuple2() || term.IsTuple3() || term.IsTuple4()) {
        ctx.IsValidMonotonic(t1, t2, tm.getFirst(term))
        ctx.IsValidMonotonic(t1, t2, tm.getSecond(term))
        if (term.IsTuple3() || term.IsTuple4()) {
            ctx.IsValidMonotonic(t1, t2, tm.getThird(term))
        }
        if (term.IsTuple4()) {
            ctx.IsValidMonotonic(t1, t2, tm.getForth(term))
        }
    }
}

ghost
decreases _ // TODO decreases because we apply an term ADT constructor in each recursive call
requires t1.isSuffix(t2)
requires ctx.GetLabel(plaintext) == plaintextLabel
requires ctx.IsValidEncrypt(t1, pk, plaintext, plaintextLabel)
ensures  ctx.IsValidEncrypt(t2, pk, plaintext, plaintextLabel)
func (ctx DefaultLabelingContext) IsValidEncryptMonotonic(t1, t2 tr.TraceEntry, pk, plaintext tm.Term, plaintextLabel label.SecrecyLabel) {
    ctx.IsValidMonotonic(t1, t2, pk)
    ctx.IsValidMonotonic(t1, t2, plaintext)
    skLabel := ctx.GetSkLabel(pk)
    ctx.CanFlowMonotonic(t1, t2, plaintextLabel, skLabel)
    if (ctx.CanFlow(t1, plaintextLabel, label.Public())) {
        ctx.CanFlowMonotonic(t1, t2, plaintextLabel, label.Public())
    } else {
        ctx.usage.PkePredMonotonic(t1, t2, u.GetUsageString(u.getUsage(ctx.GetUsage(tm.getSk(pk)))), plaintext, pk)
    }
}

ghost
pure func (ctx DefaultLabelingContext) IsLabeled(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) bool {
    return ctx.IsValid(t, term) &&
        ctx.GetLabel(term) == l
}

ghost
decreases
requires t1.isSuffix(t2)
requires ctx.IsLabeled(t1, term, l)
ensures  ctx.IsLabeled(t2, term, l)
func (ctx DefaultLabelingContext) IsLabeledMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    ctx.IsValidMonotonic(t1, t2, term)
}

ghost
pure func (ctx DefaultLabelingContext) IsSecret(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage) bool {
    return ctx.IsLabeled(t, term, l) &&
        ctx.GetUsage(term) == u.SomeUsage(usage)
}

ghost
decreases
requires t1.isSuffix(t2)
requires ctx.IsSecret(t1, term, l, usage)
ensures  ctx.IsSecret(t2, term, l, usage)
func (ctx DefaultLabelingContext) IsSecretMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage) {
    ctx.IsLabeledMonotonic(t1, t2, term, l)
}

ghost
pure func (ctx DefaultLabelingContext) GetLabel(term tm.Term) label.SecrecyLabel {
    return term.IsInteger64() ? label.Public() :
        term.IsInteger32() ? label.Public() :
        term.IsString() ? label.Public() :
        term.IsZeroString() ? label.Public() :
        term.IsPk() ? label.Public() :
        term.IsEncrypt() ? label.Public() :
        term.IsRandom() ? tm.getRandomLabel(term) :
        term.IsTuple2() ? label.Meet(ctx.GetLabel(tm.getFirst(term)), ctx.GetLabel(tm.getSecond(term))) : // intersection of audience is allowed to read
        term.IsTuple3() ? label.Meet(ctx.GetLabel(tm.getFirst(term)), label.Meet(ctx.GetLabel(tm.getSecond(term)), ctx.GetLabel(tm.getThird(term)))) :
        term.IsTuple4() ? label.Meet(ctx.GetLabel(tm.getFirst(term)), label.Meet(ctx.GetLabel(tm.getSecond(term)), label.Meet(ctx.GetLabel(tm.getThird(term)), ctx.GetLabel(tm.getForth(term))))) :
            label.Readers(set[p.Id]{}) // this is most restrictive label, i.e. no one is allowed to read
}

ghost
pure func (ctx DefaultLabelingContext) GetUsage(t tm.Term) u.UsageOption {
    return t.IsRandom() ? u.SomeUsage(tm.getRandomUsage(t)) :
        // TODO add other usages e.g. for DH or key expansion
        u.NoneUsage()
}

ghost
/** wrapper to get and check usage of a term for convenience */
pure func (ctx DefaultLabelingContext) IsPkeKey(sk tm.Term) bool {
    return (ctx.GetUsage(sk)).isSome() && (u.getUsage(ctx.GetUsage(sk))).IsPkeKey()
}

ghost
pure func (ctx DefaultLabelingContext) IsMsg(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) bool {
    return ctx.IsValid(t, term) &&
        ctx.CanFlow(t, ctx.GetLabel(term), l)
}

ghost
decreases
requires t1.isSuffix(t2)
requires ctx.IsMsg(t1, term, l)
ensures  ctx.IsMsg(t2, term, l)
func (ctx DefaultLabelingContext) IsMsgMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    ctx.IsValidMonotonic(t1, t2, term)
    ctx.CanFlowMonotonic(t1, t2, ctx.GetLabel(term), l)
}

ghost
decreases
requires ctx.CanFlow(t, l1, l2)
requires ctx.IsMsg(t, term, l1)
ensures  ctx.IsMsg(t, term, l2)
func (ctx DefaultLabelingContext) IsMsgTransitive(t tr.TraceEntry, term tm.Term, l1, l2 label.SecrecyLabel) {
    ctx.CanFlowTransitive(t, ctx.GetLabel(term), l1, l2)
}

ghost
decreases
requires term.IsTuple2()
requires ctx.IsMsg(t, tm.getFirst(term), l)
requires ctx.IsMsg(t, tm.getSecond(term), l)
ensures  ctx.IsMsg(t, term, l)
/** lemma for pairs having same label */
func (ctx DefaultLabelingContext) IsMsgTuple2Create(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    firstL := ctx.GetLabel(tm.getFirst(term))
    secondL := ctx.GetLabel(tm.getSecond(term))
    ctx.CanFlowCreateMeetLhs(t, firstL, secondL, l)
}

ghost
decreases
requires term.IsTuple3()
requires ctx.IsMsg(t, tm.getFirst(term), l)
requires ctx.IsMsg(t, tm.getSecond(term), l)
requires ctx.IsMsg(t, tm.getThird(term), l)
ensures  ctx.IsMsg(t, term, l)
/** lemma for triples having same label */
func (ctx DefaultLabelingContext) IsMsgTuple3Create(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    firstL := ctx.GetLabel(tm.getFirst(term))
    secondL := ctx.GetLabel(tm.getSecond(term))
    thirdL := ctx.GetLabel(tm.getThird(term))
    ctx.CanFlowCreateMeetLhs(t, secondL, thirdL, l)
    ctx.CanFlowReflexive(t, l)
    ctx.CanFlowCreateMeetLhs(t, firstL, l, l)
}

ghost
decreases
requires term.IsTuple4()
requires ctx.IsMsg(t, tm.getFirst(term), l)
requires ctx.IsMsg(t, tm.getSecond(term), l)
requires ctx.IsMsg(t, tm.getThird(term), l)
requires ctx.IsMsg(t, tm.getForth(term), l)
ensures  ctx.IsMsg(t, term, l)
/** lemma for quatruples having same label */
func (ctx DefaultLabelingContext) IsMsgTuple4Create(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    firstL := ctx.GetLabel(tm.getFirst(term))
    secondL := ctx.GetLabel(tm.getSecond(term))
    thirdL := ctx.GetLabel(tm.getThird(term))
    forthL := ctx.GetLabel(tm.getForth(term))
    ctx.CanFlowCreateMeetLhs(t, thirdL, forthL, l)
    ctx.CanFlowCreateMeetLhs(t, secondL, label.Meet(thirdL, forthL), l)
    ctx.CanFlowReflexive(t, l)
    ctx.CanFlowCreateMeetLhs(t, firstL, l, l)
}

ghost
decreases
requires term.IsTuple2()
requires ctx.IsMsg(t, term, l)
ensures  ctx.IsMsg(t, tm.getFirst(term), l)
ensures  ctx.IsMsg(t, tm.getSecond(term), l)
/** lemma for pairs flowing to some label */
func (ctx DefaultLabelingContext) IsMsgTuple2Resolve(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    firstL := ctx.GetLabel(tm.getFirst(term))
    secondL := ctx.GetLabel(tm.getSecond(term))
    ctx.CanFlowResolveMeetLhs(t, firstL, secondL, l)
}

ghost
decreases
requires term.IsTuple3()
requires ctx.IsMsg(t, term, l)
ensures  ctx.IsMsg(t, tm.getFirst(term), l)
ensures  ctx.IsMsg(t, tm.getSecond(term), l)
ensures  ctx.IsMsg(t, tm.getThird(term), l)
/** lemma for triples flowing to some label */
func (ctx DefaultLabelingContext) IsMsgTuple3Resolve(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    firstL := ctx.GetLabel(tm.getFirst(term))
    secondL := ctx.GetLabel(tm.getSecond(term))
    thirdL := ctx.GetLabel(tm.getThird(term))
    ctx.CanFlowResolveMeetLhs(t, firstL, label.Meet(secondL, thirdL), l)
    ctx.CanFlowResolveMeetLhs(t, secondL, thirdL, l)
}

ghost
decreases
requires term.IsTuple4()
requires ctx.IsMsg(t, term, l)
ensures  ctx.IsMsg(t, tm.getFirst(term), l)
ensures  ctx.IsMsg(t, tm.getSecond(term), l)
ensures  ctx.IsMsg(t, tm.getThird(term), l)
ensures  ctx.IsMsg(t, tm.getForth(term), l)
/** lemma for triples flowing to some label */
func (ctx DefaultLabelingContext) IsMsgTuple4Resolve(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    firstL := ctx.GetLabel(tm.getFirst(term))
    secondL := ctx.GetLabel(tm.getSecond(term))
    thirdL := ctx.GetLabel(tm.getThird(term))
    forthL := ctx.GetLabel(tm.getForth(term))
    ctx.CanFlowResolveMeetLhs(t, firstL, label.Meet(secondL, label.Meet(thirdL, forthL)), l)
    ctx.CanFlowResolveMeetLhs(t, secondL, label.Meet(thirdL, forthL), l)
    ctx.CanFlowResolveMeetLhs(t, thirdL, forthL, l)
}

ghost
decreases
requires ctx.CanFlow(t, l1, l3)
requires ctx.CanFlow(t, l2, l3)
ensures  ctx.CanFlow(t, label.Meet(l1, l2), l3)
func (ctx DefaultLabelingContext) CanFlowCreateMeetLhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    // no body needed
}

ghost
decreases
requires ctx.CanFlow(t, label.Meet(l1, l2), l3)
ensures  ctx.CanFlow(t, l1, l3)
ensures  ctx.CanFlow(t, l2, l3)
func (ctx DefaultLabelingContext) CanFlowResolveMeetLhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalResolveMeetLhs(t.getCorruptIds(), l1, l2, l3)
}

ghost
decreases
requires ctx.CanFlow(t, l1, label.Meet(l2, l2))
ensures  ctx.CanFlow(t, l1, l2)
func (ctx DefaultLabelingContext) CanFlowResolveMeetRhs(t tr.TraceEntry, l1, l2 label.SecrecyLabel) {
    ctx.canFlowInternalResolveMeetRhs(t.getCorruptIds(), l1, l2)
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
requires ctx.canFlowInternal(corruptIds, label.Meet(l1, l2), l3)
ensures  ctx.canFlowInternal(corruptIds, l1, l3)
ensures  ctx.canFlowInternal(corruptIds, l2, l3)
func (ctx DefaultLabelingContext) canFlowInternalResolveMeetLhs(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel) {
    if (l3.IsMeet() || l3.IsJoin()) {
        if (ctx.canFlowInternal(corruptIds, label.Meet(l1, l2), label.GetFirstLabel(l3))) {
            ctx.canFlowInternalResolveMeetLhs(corruptIds, l1, l2, label.GetFirstLabel(l3))
        }
        if (ctx.canFlowInternal(corruptIds, label.Meet(l1, l2), label.GetSecondLabel(l3))) {
            ctx.canFlowInternalResolveMeetLhs(corruptIds, l1, l2, label.GetSecondLabel(l3))
        }
    }
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
requires ctx.canFlowInternal(corruptIds, l1, label.Meet(l2, l2))
ensures  ctx.canFlowInternal(corruptIds, l1, l2)
func (ctx DefaultLabelingContext) canFlowInternalResolveMeetRhs(corruptIds set[p.Id], l1, l2 label.SecrecyLabel) {
    if (l1.IsMeet()) {
        if (!ctx.canFlowInternal(corruptIds, l1, l2)) {
            ctx.canFlowInternalResolveMeetRhs(corruptIds, label.GetFirstLabel(l1), l2)
            ctx.canFlowInternalResolveMeetRhs(corruptIds, label.GetSecondLabel(l1), l2)
        }
    } else if (l1.IsJoin()) {
        if (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), label.Meet(l2, l2))) {
            ctx.canFlowInternalResolveMeetRhs(corruptIds, label.GetFirstLabel(l1), l2)
        } else if (ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), label.Meet(l2, l2))) {
            ctx.canFlowInternalResolveMeetRhs(corruptIds, label.GetSecondLabel(l1), l2)
        }
    }
}

ghost
pure func (ctx DefaultLabelingContext) IsPublishable(t tr.TraceEntry, term tm.Term) bool {
    return ctx.IsMsg(t, term, label.Public())
}

ghost
decreases
requires t1.isSuffix(t2)
requires ctx.IsPublishable(t1, term)
ensures  ctx.IsPublishable(t2, term)
func (ctx DefaultLabelingContext) IsPublishableMonotonic(t1, t2 tr.TraceEntry, term tm.Term) {
    ctx.IsMsgMonotonic(t1, t2, term, label.Public())
}

ghost
pure func (ctx DefaultLabelingContext) CanFlow(t tr.TraceEntry, l1, l2 label.SecrecyLabel) bool {
    return ctx.canFlowInternal(t.getCorruptIds(), l1, l2)
}

ghost
pure func (ctx DefaultLabelingContext) canFlowInternal(corruptIds set[p.Id], l1, l2 label.SecrecyLabel) bool {
    // public can flow to anything
    return (l1.IsPublic() ==> true) &&
        // label with a corrupted reader flows to public
        (l1.IsReaders() && l2.IsPublic() ==> containsCorruptId(corruptIds, label.GetReaders(l1))) &&
        // l1 is superset of l2 or some ID in l1 is corrupt
        (l1.IsReaders() && l2.IsReaders() ==> (label.GetReaders(l2) subset label.GetReaders(l1) || containsCorruptId(corruptIds, label.GetReaders(l1)))) &&
        // l1 flows to l2 == meet(l21, l22) if l1 flows to l21 OR l22 because meet(l21, l22) is stricter than l21 or l22
        (l1.IsReaders() && l2.IsMeet() ==> ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) &&
        // l1 flows to l2 == join(l21, l22) if l1 flows to l21 AND l22
        (l1.IsReaders() && l2.IsJoin() ==> ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) &&
        (l1.IsJoin() && (l2.IsPublic() || l2.IsReaders()) ==> ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2)) &&
        (l1.IsMeet() && (l2.IsPublic() || l2.IsReaders()) ==> ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2)) &&
        (l1.IsJoin() && l2.IsMeet() ==> (ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2))) &&
        (l1.IsMeet() && l2.IsMeet() ==> (ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2))) &&
        (l1.IsMeet() && l2.IsJoin() ==> (ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2))) &&
        (l1.IsJoin() && l2.IsJoin() ==> (ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2)))
        // rule of thumb:
        // l1 being a join or l2 being a meet results in disjunctions
        // l1 being a meet or l2 being a join results in conjunctions
}

ghost
decreases
ensures  ctx.CanFlow(t, l, l)
func (ctx DefaultLabelingContext) CanFlowReflexive(t tr.TraceEntry, l label.SecrecyLabel) {
    corruptIds := t.getCorruptIds()
    ctx.canFlowInternalReflexive(corruptIds, l)
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
ensures  ctx.canFlowInternal(corruptIds, l, l)
func (ctx DefaultLabelingContext) canFlowInternalReflexive(corruptIds set[p.Id], l label.SecrecyLabel) {
    if (l.IsJoin()) {
        l1 := label.GetFirstLabel(l)
        l2 := label.GetSecondLabel(l)
        ctx.canFlowInternalReflexive(corruptIds, l1)
        ctx.canFlowInternalReflexive(corruptIds, l2)
        // the following assert stmts are needed
        assert ctx.canFlowInternal(corruptIds, l, l1)
        assert ctx.canFlowInternal(corruptIds, l, l2)
    } else if (l.IsMeet()) {
        l1 := label.GetFirstLabel(l)
        l2 := label.GetSecondLabel(l)
        ctx.canFlowInternalReflexive(corruptIds, l1)
        ctx.canFlowInternalReflexive(corruptIds, l2)
        // the following assert stmts are needed
        assert ctx.canFlowInternal(corruptIds, l1, l)
        assert ctx.canFlowInternal(corruptIds, l2, l)
    }
}

ghost
decreases
requires ctx.CanFlow(t, l1, l2)
requires ctx.CanFlow(t, l2, l3)
ensures  ctx.CanFlow(t, l1, l3)
func (ctx DefaultLabelingContext) CanFlowTransitive(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    corruptIds := t.getCorruptIds()
    ctx.canFlowInternalTransitive(corruptIds, l1, l2, l3)
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
ensures (ctx.canFlowInternal(corruptIds, l1, l2) && ctx.canFlowInternal(corruptIds, l2, l3)) ==> ctx.canFlowInternal(corruptIds, l1, l3)
func (ctx DefaultLabelingContext) canFlowInternalTransitive(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel) {
    if (l1.IsPublic()) {
        // no body needed
        return
    }
    if (l2.IsPublic()) {
        ctx.flowsToPublicCanFlow(corruptIds, l1, l3)
        return
    }
    if (l3.IsPublic()) {
        ctx.canFlowFlowsToPublic(corruptIds, l1, l2)
        return
    }

    if (l1.IsJoin() || l1.IsMeet()) {
        l11 := label.GetFirstLabel(l1)
        l12 := label.GetSecondLabel(l1)
        ctx.canFlowInternalTransitive(corruptIds, l11, l2, l3)
        ctx.canFlowInternalTransitive(corruptIds, l12, l2, l3)
    }
    if (l2.IsJoin() || l2.IsMeet()) {
        l21 := label.GetFirstLabel(l2)
        l22 := label.GetSecondLabel(l2)
        ctx.canFlowInternalTransitive(corruptIds, l1, l21, l3)
        ctx.canFlowInternalTransitive(corruptIds, l1, l22, l3)
    }
    if (l3.IsJoin() || l3.IsMeet()) {
        l31 := label.GetFirstLabel(l3)
        l32 := label.GetSecondLabel(l3)
        ctx.canFlowInternalTransitive(corruptIds, l1, l2, l31)
        ctx.canFlowInternalTransitive(corruptIds, l1, l2, l32)
    }
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
ensures  ctx.canFlowInternal(corruptIds, l1, label.Public()) ==> ctx.canFlowInternal(corruptIds, l1, l2)
func (ctx DefaultLabelingContext) flowsToPublicCanFlow(corruptIds set[p.Id], l1, l2 label.SecrecyLabel) {
    if (l1.IsJoin() || l1.IsMeet()) {
        l11 := label.GetFirstLabel(l1)
        l12 := label.GetSecondLabel(l1)
        ctx.flowsToPublicCanFlow(corruptIds, l11, l2)
        ctx.flowsToPublicCanFlow(corruptIds, l12, l2)
    }
    if (l2.IsJoin() || l2.IsMeet()) {
        l21 := label.GetFirstLabel(l2)
        l22 := label.GetSecondLabel(l2)
        ctx.flowsToPublicCanFlow(corruptIds, l1, l21)
        ctx.flowsToPublicCanFlow(corruptIds, l1, l22)
    }
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
ensures  (ctx.canFlowInternal(corruptIds, l2, label.Public()) && ctx.canFlowInternal(corruptIds, l1, l2)) ==> ctx.canFlowInternal(corruptIds, l1, label.Public())
func (ctx DefaultLabelingContext) canFlowFlowsToPublic(corruptIds set[p.Id], l1, l2 label.SecrecyLabel) {
    if (l1.IsJoin() || l1.IsMeet()) {
        l11 := label.GetFirstLabel(l1)
        l12 := label.GetSecondLabel(l1)
        ctx.canFlowFlowsToPublic(corruptIds, l11, l2)
        ctx.canFlowFlowsToPublic(corruptIds, l12, l2)
    }
    if (l2.IsJoin() || l2.IsMeet()) {
        l21 := label.GetFirstLabel(l2)
        l22 := label.GetSecondLabel(l2)
        ctx.canFlowFlowsToPublic(corruptIds, l1, l21)
        ctx.canFlowFlowsToPublic(corruptIds, l1, l22)
    }
}

ghost
decreases
requires t1.isSuffix(t2)
requires ctx.CanFlow(t1, l1, l2)
ensures  ctx.CanFlow(t2, l1, l2)
func (ctx DefaultLabelingContext) CanFlowMonotonic(t1, t2 tr.TraceEntry, l1, l2 label.SecrecyLabel) {
    ctx.CanFlowMonotonicInternal(t1, t2, l1, l2)
}

ghost
decreases _ // TODO termination via SecurityLabel deconstructors
requires t1.isSuffix(t2)
ensures  ctx.CanFlow(t1, l1, l2) ==> ctx.CanFlow(t2, l1, l2)
func (ctx DefaultLabelingContext) CanFlowMonotonicInternal(t1, t2 tr.TraceEntry, l1, l2 label.SecrecyLabel) {
    if (!l1.IsJoin() && !l1.IsMeet() && !l2.IsJoin() && !l2.IsMeet()) {
        t1.getCorruptIdsMonotonic(t2)
    } else {
        if (l1.IsJoin() || l1.IsMeet()) {
            l11 := label.GetFirstLabel(l1)
            l12 := label.GetSecondLabel(l1)
            ctx.CanFlowMonotonicInternal(t1, t2, l11, l2)
            ctx.CanFlowMonotonicInternal(t1, t2, l12, l2)
        }
        if (l2.IsJoin() || l2.IsMeet()) {
            l21 := label.GetFirstLabel(l2)
            l22 := label.GetSecondLabel(l2)
            ctx.CanFlowMonotonicInternal(t1, t2, l1, l21)
            ctx.CanFlowMonotonicInternal(t1, t2, l1, l22)
        }
    }
}

ghost
decreases
requires ctx.CanFlow(t, label.Readers(set[p.Id]{ id }), label.Public())
ensures  id in t.getCorruptIds()
func (ctx DefaultLabelingContext) CanFlowToPublicImpliesCorruption(t tr.TraceEntry, id p.Id) {
    // no body needed
}

ghost
/** returns true iff at least one id in `ids` has been corrupted, i.e. is in `corruptIds` */
pure func containsCorruptId(corruptIds set[p.Id], ids set[p.Id]) bool {
    return len(corruptIds intersection ids) > 0
}

ghost
pure func (ctx DefaultLabelingContext) GetSkLabel(pk tm.Term) label.SecrecyLabel {
    return (pk.IsPk() && ctx.IsPkeKey(tm.getSk(pk))) ?
        ctx.GetLabel(tm.getSk(pk)) :
        label.Public()
}

ghost
pure func (ctx DefaultLabelingContext) IsSecretKey(t tr.TraceEntry, owner p.Id, sk tm.Term, keyType KeyType, usage string) bool {
    // TODO case switch over all key types. We assume now that there is only KeyType `PKE`
    return (keyType == KeyTypePke() ==> ctx.IsPrivateDecKey(t, owner, sk, usage))
}

ghost
pure func (ctx DefaultLabelingContext) IsPublicKey(t tr.TraceEntry, skOwner p.Id, pk, sk tm.Term, keyType KeyType, usage string) bool {
    // TODO case switch over all key types. We assume now that there is only KeyType `PKE`
    return (keyType == KeyTypePke() ==> ctx.IsPublicEncKey(t, skOwner, pk, sk, usage))
}

ghost
pure func (ctx DefaultLabelingContext) IsPrivateDecKey(t tr.TraceEntry, owner p.Id, sk tm.Term, usage string) bool {
    return ctx.IsSecret(t, sk, label.Readers(set[p.Id]{ owner }), u.PkeKey(usage))
}

ghost
pure func (ctx DefaultLabelingContext) IsPublicEncKey(t tr.TraceEntry, skOwner p.Id, pk, sk tm.Term, usage string) bool {
    // TODO can we existentially quantify `sk`?
    return ctx.IsPublishable(t, pk) &&
        ctx.IsSecret(t, sk, label.Readers(set[p.Id]{ skOwner }), u.PkeKey(usage)) &&
        pk == tm.createPk(sk)
}

ghost
pure func (ctx DefaultLabelingContext) IsPublicEncKeyExistential(t tr.TraceEntry, pk tm.Term, l label.SecrecyLabel, usage string) bool {
    return ctx.IsPublishable(t, pk) &&
        (exists sk tm.Term :: { tm.createPk(sk) } ctx.IsSecret(t, sk, l, u.PkeKey(usage)) &&
            pk == tm.createPk(sk))
}

ghost
decreases
requires ctx.IsMsg(t, term, l1)
requires ctx.CanFlow(t, l1, l2)
ensures  ctx.IsMsg(t, term, l2)
func (ctx DefaultLabelingContext) Restrict(t tr.TraceEntry, term tm.Term, l1, l2 label.SecrecyLabel) {
    ctx.CanFlowTransitive(t, ctx.GetLabel(term), l1, l2)
}

pred (ctx DefaultLabelingContext) NonceIsUnique(nonce tm.Term) {
    acc(ctx.getNonceIsUniquePointer(nonce))
}

pred (ctx DefaultLabelingContext) NonceForEventIsUnique(nonce tm.Term, eventType ev.EventType) {
    acc(ctx.getNonceForEventIsUniquePointer(nonce, eventType))
}

// each nonce term is (injectively) mapped to a heap location for which write access
// is obtained as part of the nonce generation algorithm.
// Pairwise disjointness of nonces / their uniqueness directly follows from this property
// as otherwise the `NonceIsUnique` resource would be stored twice on the trace which immediately
// results in a contradiction when unfolding the predicate instances
type Void int // note that `struct{}` results in Gobra not generating the expected heap permissions
ghost
pure func (ctx DefaultLabelingContext) getNonceIsUniquePointer(nonce tm.Term) *Void

ghost
pure func (ctx DefaultLabelingContext) getNonceForEventIsUniquePointer(nonce tm.Term, eventType ev.EventType) *Void

ghost
decreases
requires acc(ctx.NonceForEventIsUnique(nonce, eventType), 2/1)
ensures  false
func (ctx DefaultLabelingContext) NonceForEventContradiction(nonce tm.Term, eventType ev.EventType) {
    unfold acc(ctx.NonceForEventIsUnique(nonce, eventType), 2/1)
}

ghost
pure func (ctx DefaultLabelingContext) CanEncrypt(t tr.TraceEntry, msg, pk tm.Term) bool {
    return ctx.IsPublishable(t, pk) &&
        ctx.IsMsg(t, msg, ctx.GetSkLabel(pk)) &&
        (forall usageString string :: { ctx.usage.PkePred(t, usageString, msg, pk) } ctx.IsPublicEncKeyExistential(t, pk, ctx.GetSkLabel(pk), usageString) ==>
            ctx.usage.PkePred(t, usageString, msg, pk))
}

ghost
decreases
requires ctx.CanEncrypt(t, msg, pk) || (ctx.IsPublishable(t, msg) && ctx.IsPublishable(t, pk))
ensures  ctx.IsPublishable(t, tm.encrypt(msg, pk))
func (ctx DefaultLabelingContext) CiphertextIsPublishable(t tr.TraceEntry, msg, pk tm.Term) {
    msgLabel := ctx.GetLabel(msg)
    if ctx.IsPublishable(t, msg) {
        corruptIds := t.getCorruptIds()
        ctx.flowsToPublicCanFlow(corruptIds, msgLabel, ctx.GetSkLabel(pk))
    }
    // the following assert stmt is necessary:
	assert ctx.IsValidEncrypt(t, pk, msg, msgLabel)
}

ghost
pure func (ctx DefaultLabelingContext) CanDecrypt(t tr.TraceEntry, ciphertext, sk tm.Term, skOwner p.Id) bool {
    return ctx.IsLabeled(t, sk, label.Readers(set[p.Id]{ skOwner })) &&
        ctx.IsPublishable(t, ciphertext) &&
        (ctx.IsPublishable(t, sk) || exists usageString string :: { ctx.IsPrivateDecKey(t, skOwner, sk, usageString) } ctx.IsPrivateDecKey(t, skOwner, sk, usageString))
}

ghost
pure func (ctx DefaultLabelingContext) WasDecrypted(t tr.TraceEntry, msg, sk tm.Term, skOwner p.Id) bool {
    return ctx.IsMsg(t, msg, label.Readers(set[p.Id]{ skOwner })) &&
        (forall usageString string :: { ctx.IsPrivateDecKey(t, skOwner, sk, usageString) } ctx.IsPrivateDecKey(t, skOwner, sk, usageString) ==>
            ctx.IsPublishable(t, msg) || ctx.usage.PkePred(t, usageString, msg, tm.createPk(sk)))
}

ghost
decreases
requires ctx.CanDecrypt(t, tm.encrypt(msg, tm.createPk(sk)), sk, skOwner)
ensures  ctx.WasDecrypted(t, msg, sk, skOwner)
func (ctx DefaultLabelingContext) DecryptSatisfiesInvariant(t tr.TraceEntry, msg, sk tm.Term, skOwner p.Id) {
    pk := tm.createPk(sk)
	plaintextLabel := ctx.GetLabel(msg)
	skLabel := ctx.GetLabel(sk)
	// the following assertion is necessary to derive that `ctx.IsMsg(t, msg, skLabel)`
	assert ctx.IsValidEncrypt(t, pk, msg, plaintextLabel)
	if (ctx.CanFlow(t, plaintextLabel, label.Public())) {
		ctx.CanFlowTransitive(t, plaintextLabel, label.Public(), skLabel)
	}
}

ghost
decreases
requires ctx.IsLabeled(t, term, l)
requires l.IsReaders()
requires len(label.GetReaders(l) intersection (t.getCorruptIds())) == 0
ensures  !ctx.IsPublishable(t, term)
func (ctx DefaultLabelingContext) PublishableRequiresCorruption(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    // no body needed
}
