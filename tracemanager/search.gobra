package tracemanager

import tr "github.com/ModularVerification/ReusableVerificationLibrary/trace"


/** represents the state after acquiring the mutex to then use it prove a lemma */
pred (m *TraceManager) memLocked(ctx tr.TraceContext, owner Client, lastSeenSnapshot, snapshot tr.TraceEntry) {
    acc(m) && 0 < m.nClients &&
    ctx != nil && isComparable(ctx) &&
    m.mutex.ClientHistoryMutexStateLocked(ManagerInv{ ctx }, owner, snapshot) &&
    m.mutex.LastSeenValueLocked(ManagerInv{ ctx }, owner, snapshot) == lastSeenSnapshot &&
    (ManagerInv{ ctx }).TwoStepValueInv(lastSeenSnapshot, snapshot) // &&
    // unfolding m.mutex.clientHistoryMutexState(ManagerInv{ ctx }, owner, true) in *m.mutex.currentValue == snapshot
}

ghost
decreases
requires m.Mem(ctx, owner)
ensures  tr.validTrace(ctx, snapshot)
ensures  old(m.Snapshot(ctx, owner)) == lastSeenSnapshot
ensures  lastSeenSnapshot.isSuffix(snapshot)
ensures  m.memLocked(ctx, owner, lastSeenSnapshot, snapshot)
ensures  old(unfolding m.Mem(ctx, owner) in m.mutex) == unfolding m.memLocked(ctx, owner, lastSeenSnapshot, snapshot) in m.mutex
/** utility function to lock mutex and get the valid trace predicate */
func (m *TraceManager) acquireValidTrace(ctx tr.TraceContext, owner Client) (lastSeenSnapshot, snapshot tr.TraceEntry) {
    // to obtain the validTrace predicate instance, we have to aquire the lock and apply monotonicity:
    inv := ManagerInv{ ctx }
    lastSeenSnapshot := m.Snapshot(ctx, owner)
    unfold m.Mem(ctx, owner)
    snapshot = m.mutex.Lock(inv, owner)
    unfold inv.CurrentValueInv(snapshot)
    fold m.memLocked(ctx, owner, lastSeenSnapshot, snapshot)
}

ghost
decreases
requires m.memLocked(ctx, owner, lastSeenSnapshot, snapshot)
requires tr.validTrace(ctx, snapshot)
ensures  m.Mem(ctx, owner)
ensures  m.Snapshot(ctx, owner) == lastSeenSnapshot
ensures  (unfolding m.Mem(ctx, owner) in m.mutex) == old(unfolding m.memLocked(ctx, owner, lastSeenSnapshot, snapshot) in m.mutex)
func (m *TraceManager) releaseValidTrace(ctx tr.TraceContext, owner Client, lastSeenSnapshot, snapshot tr.TraceEntry) {
    inv := ManagerInv{ ctx }
    unfold m.memLocked(ctx, owner, lastSeenSnapshot, snapshot)
    fold inv.CurrentValueInv(snapshot)
    // there is no need to update the snapshot
    m.mutex.UnlockWithSnapshot(inv, owner, snapshot, snapshot, lastSeenSnapshot)
    fold m.Mem(ctx, owner)
}

type TraceSearcher interface {
    ghost
    decreases
    pure Ctx() tr.TraceContext
    
    ghost
    decreases
    pure Matches(entry tr.TraceEntry) bool

    ghost
    decreases
    requires entry.isSuffix(snapshot)
    requires Matches(entry)
    /**
     * states additional (pure) properties about the entry that `Matches`
     */
    pure MatchProperties(snapshot, entry tr.TraceEntry) bool

    ghost
    decreases
    pure Occurs(entry tr.TraceEntry) bool

    ghost
    decreases
    requires Ctx() != nil
    pure PureEntryInv(entry tr.TraceEntry) bool

    ghost
    decreases
    requires Matches(entry)
    ensures  MatchProperties(entry, entry)
    MatchPropertiesReflexive(snapshot, entry tr.TraceEntry)

    ghost
    decreases
    requires entry.isSuffix(snapshot)
    requires Matches(entry)
    requires !Matches(snapshot)
    requires MatchProperties(tr.getPrev(snapshot), entry)
    ensures  MatchProperties(snapshot, entry)
    MatchPropertiesTransitive(snapshot, entry tr.TraceEntry)

    ghost
    decreases
    requires Occurs(entry)
    ensures  (!entry.isRoot() && Occurs(tr.getPrev(entry))) || Matches(entry)
    /** 
     * Occurs implies that either there is a match at the current entry or the right
     * entry will occur further in the trace's past. This then also implies that we
     * cannot have reached the root yet
     */
    OccursImpliesAnEventualMatch(entry tr.TraceEntry)

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires Ctx() != nil
    requires Matches(entry)
    requires acc(tr.validTrace(Ctx(), entry), p)
    ensures  PureEntryInv(entry)
    ensures  acc(tr.validTrace(Ctx(), entry), p)
    /**
     * pure component of the `validTrace` invariant that belongs to the entry that
     * was searched.
     */
    ExtractPureEntryInv(entry tr.TraceEntry, p perm)
}

ghost
decreases validTraceEntry.traceLen()
requires noPerm < p && p <= writePerm
requires searcher != nil && searcher.Ctx() != nil // && searcher.Mem()
requires acc(tr.validTrace(searcher.Ctx(), validTraceEntry), p)
requires entry.isSuffix(validTraceEntry)
requires searcher.Occurs(entry)
ensures  prev.isSuffix(entry)
ensures  searcher.Matches(prev)
ensures  searcher.MatchProperties(entry, prev)
ensures  searcher.PureEntryInv(prev)
ensures  acc(tr.validTrace(searcher.Ctx(), prev), p)
ensures  acc(tr.validTrace(searcher.Ctx(), prev), p) --* acc(tr.validTrace(searcher.Ctx(), validTraceEntry), p)
// this lemma is part of the manager as it requires the validTrace predicate
// we have two separate TraceEntry args (`validTraceEntry` and `entry`) such that the validTrace predicate instance can be provided for a possibly longer trace
// this indirectly strengthens the postcondition because `prev` is a suffix of `entry` instead of `validTraceEntry`
/**
 * Searches on the trace for an existing entry and returns this entry.
 * Furthermore, the (impure) valid trace invariant at the time point back then is returned.
 */
func (m *TraceManager) findEntryWithInv(searcher TraceSearcher, validTraceEntry, entry tr.TraceEntry, p perm) (prev tr.TraceEntry) {
    ctx := searcher.Ctx()
    if validTraceEntry == entry {
        unfold acc(tr.validTrace(ctx, validTraceEntry), p)
        if searcher.Matches(validTraceEntry) {
            // entry has been found
            prev = validTraceEntry
            searcher.MatchPropertiesReflexive(prev, prev)
            fold acc(tr.validTrace(searcher.Ctx(), validTraceEntry), p)
            searcher.ExtractPureEntryInv(prev, p)
            package acc(tr.validTrace(searcher.Ctx(), prev), p) --* acc(tr.validTrace(searcher.Ctx(), validTraceEntry), p)
        } else {
            // recurse
            searcher.OccursImpliesAnEventualMatch(validTraceEntry)
            prev = m.findEntryWithInv(searcher, tr.getPrev(validTraceEntry), tr.getPrev(validTraceEntry), p)
            searcher.MatchPropertiesTransitive(validTraceEntry, prev)
            package acc(tr.validTrace(ctx, prev), p) --* acc(tr.validTrace(ctx, validTraceEntry), p) {
                apply acc(tr.validTrace(ctx, prev), p) --* acc(tr.validTrace(ctx, tr.getPrev(validTraceEntry)), p)
                fold acc(tr.validTrace(ctx, validTraceEntry), p)
            }
        }
    } else {
        unfold acc(tr.validTrace(ctx, validTraceEntry), p)
        prev = m.findEntryWithInv(searcher, tr.getPrev(validTraceEntry), entry, p)
        package acc(tr.validTrace(ctx, prev), p) --* acc(tr.validTrace(ctx, validTraceEntry), p) {
            apply acc(tr.validTrace(ctx, prev), p) --* acc(tr.validTrace(ctx, tr.getPrev(validTraceEntry)), p)
            fold acc(tr.validTrace(ctx, validTraceEntry), p)
        }
    }
}

ghost
decreases
requires searcher != nil && searcher.Ctx() != nil
requires m.Mem(searcher.Ctx(), owner)
requires searcher.Occurs(m.Snapshot(searcher.Ctx(), owner))
ensures  m.Mem(searcher.Ctx(), owner)
ensures  searcher.Occurs(m.Snapshot(searcher.Ctx(), owner))
ensures  prev.isSuffix(m.Snapshot(searcher.Ctx(), owner)) && searcher.Matches(
    prev)
ensures  searcher.PureEntryInv(prev)
ensures  searcher.MatchProperties(m.Snapshot(searcher.Ctx(), owner), prev)
ensures  old(m.Snapshot(searcher.Ctx(), owner)) == m.Snapshot(searcher.Ctx(), owner)
ensures  m.ImmutableState(searcher.Ctx(), owner) == old(m.ImmutableState(searcher.Ctx(), owner))
/**
 * Searches on the trace for an existing entry and returns this entry.
 * Furthermore, the pure invariant for the located entry is returned.
 */
func (m *TraceManager) findEntryWithPureInv(searcher TraceSearcher, owner Client) (prev tr.TraceEntry) {
    prev = m.findEntryWithPureInvWithSnap(searcher, owner, m.Snapshot(searcher.Ctx(), owner))
}

ghost
decreases
requires searcher != nil && searcher.Ctx() != nil
requires m.Mem(searcher.Ctx(), owner)
requires snap.isSuffix(m.Snapshot(searcher.Ctx(), owner))
requires searcher.Occurs(snap)
ensures  m.Mem(searcher.Ctx(), owner)
ensures  prev.isSuffix(snap) && searcher.Matches(prev)
ensures  searcher.PureEntryInv(prev)
ensures  searcher.MatchProperties(snap, prev)
ensures  old(m.Snapshot(searcher.Ctx(), owner)) == m.Snapshot(searcher.Ctx(), owner)
ensures  m.ImmutableState(searcher.Ctx(), owner) == old(m.ImmutableState(searcher.Ctx(), owner))
/**
 * Searches on the trace for an existing entry and returns this entry.
 * Furthermore, the pure invariant for the located entry is returned.
 */
func (m *TraceManager) findEntryWithPureInvWithSnap(searcher TraceSearcher, owner Client, snap tr.TraceEntry) (prev tr.TraceEntry) {
    // to obtain the validTrace predicate instance, we have to aquire the lock and apply monotonicity:
    lastSeenSnapshot, snapshot := m.acquireValidTrace(searcher.Ctx(), owner)
    snap.isSuffixTransitive(lastSeenSnapshot, snapshot)
    prev = m.findEntryWithInv(searcher, snapshot, snap, 1/2)
    apply acc(tr.validTrace(searcher.Ctx(), prev), 1/2) --* acc(tr.validTrace(searcher.Ctx(), snapshot), 1/2)
    m.releaseValidTrace(searcher.Ctx(), owner, lastSeenSnapshot, snapshot)
}

/** this is the same as the `validTrace` predicate but without the recursive component */
pred localValidTrace(ctx tr.TraceContext, t tr.TraceEntry) {
    ctx != nil &&
    (t.isRoot() ==> tr.publicInv(ctx, tr.getPublicTerms(t), t)) &&
    (t.isEvent() ==> ctx.eventInv(tr.getPrincipal(t), tr.getEvent(t), tr.getPrev(t))) &&
    (t.isMessage() ==> tr.messageInv(ctx, tr.getSender(t), tr.getReceiver(t), tr.getPayload(t), tr.getPrev(t))) &&
    (t.isDropMessage() ==> tr.messageInv(ctx, tr.getSender(t), tr.getReceiver(t), tr.getPayload(t), tr.getPrev(t))) &&
    (t.isNonce() ==> tr.randInv(ctx, tr.getNonce(t), tr.getPrev(t))) &&
    (t.isPublic() ==> tr.madePublicInv(ctx, tr.getPayload(t), tr.getPrev(t))) &&
    (t.isCorrupt() ==> ctx.corruptInv(tr.getId(t), tr.getPrev(t)))
}

ghost
decreases validTraceEntry.traceLen()
requires searcher1 != nil && searcher2 != nil
requires isComparable(searcher1.Ctx()) && searcher1.Ctx() == searcher2.Ctx()
requires tr.validTrace(searcher1.Ctx(), validTraceEntry)
requires searcher1.Occurs(validTraceEntry)
requires searcher2.Occurs(validTraceEntry)
ensures  s1.isSuffix(validTraceEntry)
ensures  searcher1.Matches(s1)
ensures  searcher1.MatchProperties(validTraceEntry, s1)
ensures  s2.isSuffix(validTraceEntry)
ensures  searcher2.Matches(s2)
ensures  searcher2.MatchProperties(validTraceEntry, s2)
ensures  s1 == s2 ==>
    localValidTrace(searcher1.Ctx(), s1) &&
    (localValidTrace(searcher1.Ctx(), s1) --* tr.validTrace(searcher1.Ctx(), validTraceEntry))
ensures s1 != s2 ==>
    localValidTrace(searcher1.Ctx(), s1) &&
    localValidTrace(searcher2.Ctx(), s2) &&
    ((localValidTrace(searcher1.Ctx(), s1) && localValidTrace(searcher2.Ctx(), s2)) --* tr.validTrace(searcher1.Ctx(), validTraceEntry))
// this lemma is part of the manager as it requires the validTrace predicate
func (m *TraceManager) findEntriesWithInv(searcher1, searcher2 TraceSearcher, validTraceEntry tr.TraceEntry) (s1, s2 tr.TraceEntry) {
    ctx := searcher1.Ctx()
    s1Found := false
    s2Found := false
    unfold tr.validTrace(ctx, validTraceEntry)
    if searcher1.Matches(validTraceEntry) {
        // entry 1 found
        s1Found = true
        s1 = validTraceEntry
        searcher1.MatchPropertiesReflexive(s1, s1)
    }
    if searcher2.Matches(validTraceEntry) {
        // entry 2 found
        s2Found = true
        s2 = validTraceEntry
        searcher2.MatchPropertiesReflexive(s2, s2)
    }

    // apply some lemmas before potentially recursing on the trace:
    if !s1Found {
        searcher1.OccursImpliesAnEventualMatch(validTraceEntry)
    }
    if !s2Found {
        searcher2.OccursImpliesAnEventualMatch(validTraceEntry)
    }

    // recurse if necessary
    if s1Found && s2Found {
        fold localValidTrace(ctx, s1)
        package localValidTrace(ctx, s1) --* tr.validTrace(ctx, validTraceEntry) {
            unfold localValidTrace(ctx, s1)
            fold tr.validTrace(ctx, validTraceEntry)
        }
    } else if s1Found && !s2Found {
        // s1 is more recent than s2
        s2 = m.findEntryWithInv(searcher2, tr.getPrev(validTraceEntry), tr.getPrev(validTraceEntry), writePerm)
        fold localValidTrace(ctx, s1)
        unfold tr.validTrace(ctx, s2)
        fold localValidTrace(ctx, s2)
        package (localValidTrace(ctx, s1) && localValidTrace(ctx, s2)) --* tr.validTrace(ctx, validTraceEntry) {
            unfold localValidTrace(ctx, s2)
            fold tr.validTrace(ctx, s2)
            apply tr.validTrace(ctx, s2) --* tr.validTrace(ctx, tr.getPrev(validTraceEntry))
            unfold localValidTrace(ctx, s1)
            fold tr.validTrace(ctx, validTraceEntry)
        }
    } else if !s1Found && s2Found {
        // s2 is more recent than s1
        s1 = m.findEntryWithInv(searcher1, tr.getPrev(validTraceEntry), tr.getPrev(validTraceEntry), writePerm)
        unfold tr.validTrace(ctx, s1)
        fold localValidTrace(ctx, s1)
        fold localValidTrace(ctx, s2)
        package (localValidTrace(ctx, s1) && localValidTrace(ctx, s2)) --* tr.validTrace(ctx, validTraceEntry) {
            unfold localValidTrace(ctx, s1)
            fold tr.validTrace(ctx, s1)
            apply tr.validTrace(ctx, s1) --* tr.validTrace(ctx, tr.getPrev(validTraceEntry))
            unfold localValidTrace(ctx, s2)
            fold tr.validTrace(ctx, validTraceEntry)
        }
    } else {
        s1, s2 = m.findEntriesWithInv(searcher1, searcher2, tr.getPrev(validTraceEntry))
        s1.isSuffixTransitive(tr.getPrev(validTraceEntry), validTraceEntry)
        s2.isSuffixTransitive(tr.getPrev(validTraceEntry), validTraceEntry)
        if s1 == s2 {
            package localValidTrace(ctx, s1) --* tr.validTrace(ctx, validTraceEntry) {
                apply localValidTrace(ctx, s1) --* tr.validTrace(ctx, tr.getPrev(validTraceEntry))
                fold tr.validTrace(ctx, validTraceEntry)
            }
        } else {
            package (localValidTrace(searcher1.Ctx(), s1) && localValidTrace(searcher2.Ctx(), s2)) --* tr.validTrace(searcher1.Ctx(), validTraceEntry) {
                apply (localValidTrace(searcher1.Ctx(), s1) && localValidTrace(searcher2.Ctx(), s2)) --* tr.validTrace(searcher1.Ctx(), tr.getPrev(validTraceEntry))
                fold tr.validTrace(ctx, validTraceEntry)
            }
        }
    }

    // apply some lemma after recursing
    if !s1Found {
        searcher1.MatchPropertiesTransitive(validTraceEntry, s1)
    }
    if !s2Found {
        searcher2.MatchPropertiesTransitive(validTraceEntry, s2)
    }
}
