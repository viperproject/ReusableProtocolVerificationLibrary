package tracemanager

import ev "github.com/ModularVerification/ReusableVerificationLibrary/event"
import p "github.com/ModularVerification/ReusableVerificationLibrary/principal"
import tr "github.com/ModularVerification/ReusableVerificationLibrary/trace"


type EventSearcher struct {
    ctx tr.TraceContext
    principal p.Principal
    event ev.Event
}
EventSearcher implements TraceSearcher

ghost
pure func (es EventSearcher) Ctx() tr.TraceContext {
    return es.ctx
}

ghost
decreases
requires entry.isSuffix(snapshot)
requires es.Occurs(snapshot)
pure func (es EventSearcher) Matches(snapshot tr.TraceEntry, entry tr.TraceEntry) bool {
    return entry.isEventAt(es.principal, es.event) &&
        entry == snapshot.eventOccursWitness(es.principal, es.event)
}

ghost
decreases
pure func (es EventSearcher) Occurs(entry tr.TraceEntry) bool {
    return entry.eventOccurs(es.principal, es.event)
}

ghost
// decreases
pure func (es EventSearcher) PureEntryInv(entry tr.TraceEntry) bool {
    return (es.ctx).pureEventInv(es.principal, es.event, tr.getPrev(entry))
}

ghost
decreases
requires entry.isSuffix(snapshot)
requires es.Occurs(snapshot)
requires es.Occurs(entry)
ensures  (!entry.isRoot() && es.Occurs(tr.getPrev(entry))) || es.Matches(snapshot, entry)
func (es EventSearcher) OccursImpliesAnEventualMatch(snapshot tr.TraceEntry, entry tr.TraceEntry) {
    // no body needed
}

ghost
decreases
requires snapshot1 == tr.getPrev(snapshot2)
requires entry.isSuffix(snapshot1)
requires entry.isSuffix(snapshot2)
requires es.Occurs(snapshot1)
requires es.Occurs(snapshot2)
requires es.Matches(snapshot1, entry)
requires !es.Matches(snapshot2, entry)
ensures  es.Occurs(entry)
ensures  entry.isSuffix(snapshot2)
ensures  es.Matches(snapshot2, entry)
func (es EventSearcher) MatchesTransitive(snapshot1, snapshot2, entry tr.TraceEntry) {
    // no body needed
}

ghost
decreases
requires noPerm < p && p <= writePerm
requires entry.isSuffix(snapshot)
requires es.Occurs(snapshot)
requires es.Matches(snapshot, entry)
requires acc(tr.validTrace(es.Ctx(), entry), p)
ensures  es.PureEntryInv(entry)
ensures  acc(tr.validTrace(es.Ctx(), entry), p)
func (es EventSearcher) ExtractPureEntryInv(snapshot, entry tr.TraceEntry, p perm) {
    unfold acc(tr.validTrace(es.Ctx(), entry), p)
    (es.Ctx()).getPureEventInv(es.principal, es.event, tr.getPrev(entry), p)
    fold acc(tr.validTrace(es.Ctx(), entry), p)
}
// end of EventSearcher's implementation


ghost
decreases
requires m.Mem(ctx, owner)
requires snap.isSuffix(m.Snapshot(ctx, owner))
requires snap.eventOccurs(principal, event)
ensures  m.Mem(ctx, owner)
ensures  prev.isSuffix(snap) && prev.isEvent()
ensures  prev.isSuffix(m.Snapshot(ctx, owner))
ensures  prev.isEventAt(principal, event)
ensures  prev == m.Snapshot(ctx, owner).eventOccursWitness(principal, event)
ensures  ctx.pureEventInv(principal, event, tr.getPrev(prev))
ensures  old(m.Snapshot(ctx, owner)) == m.Snapshot(ctx, owner)
ensures  m.ImmutableState(ctx, owner) == old(m.ImmutableState(ctx, owner))
func (m *TraceManager) EventOccursImpliesEventInvWithSnap(ctx tr.TraceContext, owner Client, snap tr.TraceEntry, principal p.Principal, event ev.Event) (prev tr.TraceEntry) {
    searcher := EventSearcher{ ctx, principal, event }
    prev = m.findEntryWithPureInvWithSnap(searcher, owner, snap)
    prev.isSuffixTransitive(snap, m.Snapshot(ctx, owner))
}

ghost
decreases
requires m.Mem(ctx, owner)
requires m.Snapshot(ctx, owner).eventOccurs(principal1, event1)
requires m.Snapshot(ctx, owner).eventOccurs(principal2, event2)
requires ctx.IsUnique(event1.typ)
requires event1.typ == event2.typ
requires ctx.EventConsistency(event1) && ctx.EventConsistency(event2)
requires ctx.UniquenessWitness(event1) == ctx.UniquenessWitness(event2)
ensures  m.Mem(ctx, owner)
ensures  principal1 == principal2
ensures  event1 == event2
ensures  old(m.Snapshot(ctx, owner)) == m.Snapshot(ctx, owner)
ensures  m.ImmutableState(ctx, owner) == old(m.ImmutableState(ctx, owner))
// this lemma is part of the manager as it requires the validTrace predicate
func (m *TraceManager) UniqueEventsAreUnique(ctx tr.TraceContext, owner Client, principal1, principal2 p.Principal, event1, event2 ev.Event) {
    // to obtain the validTrace predicate instance, we have to aquire the lock and apply monotonicity:
    inv := ManagerInv{ ctx }
    lastSeenTrace := m.Snapshot(ctx, owner)
    unfold m.Mem(ctx, owner)
    trace := m.mutex.Lock(inv, owner)
    unfold inv.CurrentValueInv(trace)
    lastSeenTrace.eventOccursMonotonic(trace, principal1, event1)
    lastSeenTrace.eventOccursMonotonic(trace, principal2, event2)
    s1, s2 := m.findEvents(ctx, trace, principal1, principal2, event1, event2)
    if (s1 != s2) {
        // derive contradiction
        nonce1 := ctx.isUniqueImpliesUniqueResource(principal1, event1, tr.getPrev(s1))
        nonce2 := ctx.isUniqueImpliesUniqueResource(principal2, event2, tr.getPrev(s2))
        ctx.GetLabeling().NonceForEventContradiction(nonce1, event1.typ)
    }
    // the following assertion would hold:
    // assert s1 == s2
    apply ctx.eventInv(principal1, event1, tr.getPrev(s1)) --* tr.validTrace(ctx, trace)
    fold inv.CurrentValueInv(trace)
    // there is no need to update the snapshot
    m.mutex.UnlockWithSnapshot(inv, owner, trace, trace, lastSeenTrace)
    fold m.Mem(ctx, owner)
}

ghost
decreases
requires m.Mem(ctx, owner)
requires suffix.isSuffix(m.Snapshot(ctx, owner))
requires suffix.eventOccurs(principal, event)
requires ctx.IsUnique(event.typ)
ensures  m.Mem(ctx, owner)
ensures  m.Snapshot(ctx, owner).eventOccurs(principal, event)
ensures  suffix.eventOccursWitness(principal, event) == m.Snapshot(ctx, owner).eventOccursWitness(principal, event)
ensures  old(m.Snapshot(ctx, owner)) == m.Snapshot(ctx, owner)
ensures  m.ImmutableState(ctx, owner) == old(m.ImmutableState(ctx, owner))
func (m *TraceManager) UniqueEventsOccurOnlyOnce(ctx tr.TraceContext, owner Client, suffix tr.TraceEntry, principal p.Principal, event ev.Event) {
    inv := ManagerInv{ ctx }
    lastSeenTrace := m.Snapshot(ctx, owner)
    suffix.eventOccursMonotonic(lastSeenTrace, principal, event)

    suffixWitness := suffix.eventOccursWitness(principal, event)
    suffixWitness.isSuffixTransitive(suffix, lastSeenTrace)
    traceWitness := lastSeenTrace.eventOccursWitness(principal, event)

    unfold m.Mem(ctx, owner)
    trace := m.mutex.Lock(inv, owner)
    unfold inv.CurrentValueInv(trace)
    searcher1 := EntrySearcher{ ctx, suffixWitness }
    searcher2 := EntrySearcher{ ctx, traceWitness }
    suffixWitness.isSuffixTransitive(lastSeenTrace, trace)
    traceWitness.isSuffixTransitive(lastSeenTrace, trace)
    s1, s2 := m.findEntriesWithInv(searcher1, searcher2, trace)
    if s1 == s2 {
        apply localValidTrace(ctx, s1) --* tr.validTrace(ctx, trace)
    } else {
        // derive contradiction
        unfold localValidTrace(ctx, s1)
        unfold localValidTrace(ctx, s2)
        nonce1 := ctx.isUniqueImpliesUniqueResource(principal, event, tr.getPrev(s1))
        nonce2 := ctx.isUniqueImpliesUniqueResource(principal, event, tr.getPrev(s2))
        ctx.GetLabeling().NonceForEventContradiction(nonce1, event.typ)
    }
    fold inv.CurrentValueInv(trace)
    // there is no need to update the snapshot
    m.mutex.UnlockWithSnapshot(inv, owner, trace, trace, lastSeenTrace)
    fold m.Mem(ctx, owner)
}

ghost
decreases
requires isComparable(ctx)
requires tr.validTrace(ctx, validTraceEntry)
requires validTraceEntry.eventOccurs(principal1, event1)
requires validTraceEntry.eventOccurs(principal2, event2)
ensures  s1.isEventAt(principal1, event1)
ensures  s2.isEventAt(principal2, event2)
ensures  s1 == s2 ==>
    principal1 == principal2 &&
    event1 == event2 &&
    ctx.eventInv(principal1, event1, tr.getPrev(s1)) &&
    (ctx.eventInv(principal1, event1, tr.getPrev(s1)) --* tr.validTrace(ctx, validTraceEntry))
ensures s1 != s2 ==>
    ctx.eventInv(principal1, event1, tr.getPrev(s1)) &&
    ctx.eventInv(principal2, event2, tr.getPrev(s2))
func (m *TraceManager) findEvents(ctx tr.TraceContext, validTraceEntry tr.TraceEntry, principal1, principal2 p.Principal, event1, event2 ev.Event) (s1, s2 tr.TraceEntry) {
    searcher1 := EventSearcher{ ctx, principal1, event1 }
    searcher2 := EventSearcher{ ctx, principal2, event2 }
    s1, s2 = m.findEntriesWithInv(searcher1, searcher2, validTraceEntry)
    unfold localValidTrace(ctx, s1)
    if s1 == s2 {
        package ctx.eventInv(principal1, event1, tr.getPrev(s1)) --* tr.validTrace(ctx, validTraceEntry) {
            fold localValidTrace(ctx, s1)
            apply localValidTrace(ctx, s1) --* tr.validTrace(ctx, validTraceEntry)
        }
    } else {
        unfold localValidTrace(ctx, s2) 
    }
}
