package trace

import . "github.com/ModularVerification/ReusableVerificationLibrary/event"
import label "github.com/ModularVerification/ReusableVerificationLibrary/label"
import p "github.com/ModularVerification/ReusableVerificationLibrary/principal"
import tm "github.com/ModularVerification/ReusableVerificationLibrary/term"
import u "github.com/ModularVerification/ReusableVerificationLibrary/usage"

type TraceContext interface {
    ghost
    decreases
    /** used to express (pure) properties about fields of TraceContext implementations */
    pure Props() bool

    pred eventInv(principal p.Principal, ev Event, prev TraceEntry)

    ghost
    decreases
    /**
     * Specifies consistency conditions for an event. These conditions
     * have to be implied by `pureEventInv`
     */
    pure EventConsistency(ev Event) bool

    ghost
    decreases
    pure pureEventInv(principal p.Principal, ev Event, prev TraceEntry) bool

    ghost
    decreases
    requires pureEventInv(principal, ev, prev)
    ensures  EventConsistency(ev)
    eventInvImpliesConsistency(principal p.Principal, ev Event, prev TraceEntry)
    
    ghost
    decreases
    /**
     * expresses whether an event type does only occur once with 
     * certain parameters
     */
    pure IsUnique(typ EventType) bool

    ghost
    decreases
    requires EventConsistency(ev)
    requires IsUnique(ev.typ)
    /** 
     * returns the witness from which event uniqueness can be derived.
     * This typically is a nonce stored as an event parameter
     */
    pure UniquenessWitness(ev Event) tm.Term

    ghost
    decreases
    requires Props()
    requires IsUnique(ev.typ)
    requires eventInv(principal, ev, prev)
    ensures  EventConsistency(ev)
    ensures  nonce == UniquenessWitness(ev)
    ensures  GetLabeling().NonceForEventIsUnique(nonce, ev.typ)
    ensures  GetLabeling().NonceForEventIsUnique(nonce, ev.typ) --* eventInv(principal, ev, prev)
    isUniqueImpliesUniqueResource(principal p.Principal, ev Event, prev TraceEntry) (nonce tm.Term)

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires acc(eventInv(principal, ev, prev), p)
    ensures  acc(eventInv(principal, ev, prev), p)
    ensures  pureEventInv(principal, ev, prev)
    getPureEventInv(principal p.Principal, ev Event, prev TraceEntry, p perm)

    ghost
    decreases
    requires t1.isSuffix(t2)
    requires eventInv(principal, ev, t1)
    ensures  eventInv(principal, ev, t2)
    eventInvMonotonic(principal p.Principal, ev Event, t1 TraceEntry, t2 TraceEntry)

    ghost
    decreases
    requires t1.isSuffix(t2)
    requires pureEventInv(principal, ev, t1)
    ensures  pureEventInv(principal, ev, t2)
    pureEventInvMonotonic(principal p.Principal, ev Event, t1 TraceEntry, t2 TraceEntry)

    ghost
    decreases
    requires Props()
    ensures res != nil && res.Props()
    pure GetLabeling() (res LabelingContext)
}

type LabelingContext interface {
    ghost
    decreases
    // pure properties that are carried along. Useful to specify (pure) properties about
    // the fields of an implementation. Note that it's purposefully not a predicate such
    // that the other pure functions in this interface remain heap-independent.
    pure Props() bool

    pred NonceIsUnique(nonce tm.Term)
    pred NonceForEventIsUnique(nonce tm.Term, eventType EventType)

    ghost
    decreases
    requires Props()
    requires acc(NonceForEventIsUnique(nonce, eventType), 2/1)
    ensures  false
    NonceForEventContradiction(nonce tm.Term, eventType EventType)

    ghost
    decreases
    requires Props()
    pure IsSecret(t TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage) bool

    ghost
    decreases
    requires Props()
    pure IsLabeled(t TraceEntry, term tm.Term, l label.SecrecyLabel) bool

    ghost
    decreases
    requires Props()
    pure IsPublishable(t TraceEntry, term tm.Term) bool

    ghost
    decreases
    pure CanFlow(t TraceEntry, l1, l2 label.SecrecyLabel) bool

    ghost
    decreases
    requires Props()
    requires t1.isSuffix(t2)
    requires IsSecret(t1, term, l, usage)
    ensures  IsSecret(t2, term, l, usage)
    IsSecretMonotonic(t1, t2 TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage)

    ghost
    decreases
    requires Props()
    requires t1.isSuffix(t2)
    requires IsLabeled(t1, term, l)
    ensures  IsLabeled(t2, term, l)
    IsLabeledMonotonic(t1, t2 TraceEntry, term tm.Term, l label.SecrecyLabel)

    ghost
    decreases
    requires Props()
    requires t1.isSuffix(t2)
    requires IsPublishable(t1, term)
    ensures  IsPublishable(t2, term)
    IsPublishableMonotonic(t1, t2 TraceEntry, term tm.Term)

    ghost
    decreases
    ensures  CanFlow(t, l, l)
    CanFlowReflexive(t TraceEntry, l label.SecrecyLabel)

    ghost
    decreases
    requires Props()
    pure CanEncrypt(t TraceEntry, msg, pk tm.Term) bool

    ghost
    decreases
    requires Props()
    requires CanEncrypt(t, msg, pk) || (IsPublishable(t, msg) && IsPublishable(t, pk))
    ensures  IsPublishable(t, tm.encrypt(msg, pk))
    CiphertextIsPublishable(t TraceEntry, msg, pk tm.Term)

    ghost
    decreases
    requires Props()
    pure CanDecrypt(t TraceEntry, ciphertext, sk tm.Term, skOwner p.Id) bool

    ghost
    decreases
    requires Props()
    pure WasDecrypted(t TraceEntry, msg, sk tm.Term, skOwner p.Id) bool

    ghost
    decreases
    requires Props()
    requires IsPublishable(t, ciphertext) && IsPublishable(t, sk)
    ensures  CanDecrypt(t, ciphertext, sk, skOwner)
    CanDecryptWithPublicSk(t TraceEntry, ciphertext, sk tm.Term, skOwner p.Id)

    ghost
    decreases
    requires Props()
    requires CanDecrypt(t, tm.encrypt(msg, tm.createPk(sk)), sk, skOwner)
    ensures  WasDecrypted(t, msg, sk, skOwner)
    DecryptSatisfiesInvariant(t TraceEntry, msg, sk tm.Term, skOwner p.Id)

    ghost
    decreases
    requires Props()
    requires IsPublishable(t, tm.encrypt(msg, tm.createPk(sk))) && IsPublishable(t, sk)
    ensures  IsPublishable(t, msg)
    PlaintextIsPublishableForPublicSk(t TraceEntry, msg, sk tm.Term, skOwner p.Id)

    ghost
    decreases
    requires Props()
    pure CanAeadEncrypt(t TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel) bool

    ghost
    decreases
    requires Props()
    requires CanAeadEncrypt(t, key, nonce, msg, ad, keyL) || (IsPublishable(t, key) && IsPublishable(t, nonce) && IsPublishable(t, msg) && IsPublishable(t, ad))
    ensures  IsPublishable(t, tm.aead(key, nonce, msg, ad))
    AeadCiphertextIsPublishable(t TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel)

    ghost
    decreases
    requires Props()
    pure CanAeadDecrypt(t TraceEntry, key, nonce, ciphertext, ad tm.Term, keyL label.SecrecyLabel) bool

    ghost
    decreases
    requires Props()
    pure WasAeadDecrypted(t TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel) bool

    ghost
    decreases
    requires Props()
    requires IsPublishable(t, key) && IsPublishable(t, nonce) && IsPublishable(t, ciphertext) && IsPublishable(t, ad)
    ensures  CanAeadDecrypt(t, key, nonce, ciphertext, ad, keyL)
    CanAeadDecryptWithPublishableKey(t TraceEntry, key, nonce, ciphertext, ad tm.Term, keyL label.SecrecyLabel)

    ghost
    decreases
    requires Props()
    requires CanAeadDecrypt(t, key, nonce, tm.aead(key, nonce, msg, ad), ad, keyL)
    ensures  WasAeadDecrypted(t, key, nonce, msg, ad, keyL)
    AeadDecryptSatisfiesInvariant(t TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel)

    ghost
    decreases
    requires Props()
    requires IsPublishable(t, tm.aead(key, nonce, msg, ad)) && IsPublishable(t, key) && IsPublishable(t, nonce) && IsPublishable(t, ad)
    ensures  IsPublishable(t, msg)
    PlaintextIsPublishableForPublishableKey(t TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel)

    ghost
    decreases
    requires Props()
    requires IsLabeled(t, term, l)
    requires l.IsReaders()
    requires !containsCorruptId(t.getCorruptIds(), label.GetReaders(l))
    ensures  !IsPublishable(t, term)
    PublishableRequiresCorruption(t TraceEntry, term tm.Term, l label.SecrecyLabel)

    // TODO: reduce this interface to the bare minimum (I guess `IsPublishable` & `IsLabeled`) and instead offer
    // a `ApplyMonotonicity` method that can have arbitrary spec for each labeling implementation
}

// because Go & Gobra do not allow receivers of interface type, `ctx` becomes the first argument:
pred validTrace(ctx TraceContext, t TraceEntry) {
    ctx != nil && ctx.Props() &&
    // invariant holds recursively:
    (!t.isRoot() ==> validTrace(ctx, getPrev(t))) &&

    (t.isRoot() ==> publicInv(ctx, getPublicTerms(t), t)) &&
    (t.isEvent() ==> ctx.eventInv(getPrincipal(t), getEvent(t), getPrev(t))) &&
    (t.isMessage() ==> messageInv(ctx, getSender(t), getReceiver(t), getPayload(t), getPrev(t))) &&
    (t.isDropMessage() ==> messageInv(ctx, getSender(t), getReceiver(t), getPayload(t), getPrev(t))) &&
    (t.isNonce() ==> randInv(ctx, getNonce(t), getPrev(t))) &&
    (t.isPublic() ==> madePublicInv(ctx, getPayload(t), getPrev(t)))
}

ghost
decreases
requires ctx != nil && ctx.Props()
requires t.isRoot()
pure func publicInv(ctx TraceContext, publicTerms set[tm.Term], t TraceEntry) bool {
    return forall publicTerm tm.Term :: { publicTerm in publicTerms } publicTerm in publicTerms ==> ctx.GetLabeling().IsPublishable(t, publicTerm)
}

ghost
decreases
requires ctx != nil && ctx.Props()
pure func messageInv(ctx TraceContext, sender, receiver p.Principal, payload tm.Term, prev TraceEntry) bool {
    return ctx.GetLabeling().IsPublishable(prev, payload)
}

ghost
decreases
requires ctx != nil && ctx.Props()
requires t1.isSuffix(t2)
requires messageInv(ctx, sender, receiver, payload, t1)
ensures  messageInv(ctx, sender, receiver, payload, t2)
func messageInvTransitive(ctx TraceContext, sender, receiver p.Principal, payload tm.Term, t1, t2 TraceEntry) {
    ctx.GetLabeling().IsPublishableMonotonic(t1, t2, payload)
}

pred randInv(ctx TraceContext, nonce tm.Term, prev TraceEntry) {
    ctx != nil && ctx.Props() &&
    pureRandInv(ctx, nonce, prev) &&
    ctx.GetLabeling().NonceIsUnique(nonce)
}

ghost
decreases
pure func pureRandInv(ctx TraceContext, nonce tm.Term, prev TraceEntry) bool {
    return nonce.IsRandom()
}

ghost
decreases
requires ctx != nil && ctx.Props()
pure func madePublicInv(ctx TraceContext, term tm.Term, prev TraceEntry) bool {
    return ctx.GetLabeling().IsPublishable(prev, term)
}

ghost
decreases
requires ctx != nil && ctx.Props()
requires t1.isSuffix(t2)
requires madePublicInv(ctx, term, t1)
ensures  madePublicInv(ctx, term, t2)
func madePublicInvTransitive(ctx TraceContext, term tm.Term, t1, t2 TraceEntry) {
    ctx.GetLabeling().IsPublishableMonotonic(t1, t2, term)
}
