package trace

import . "github.com/ModularVerification/ReusableVerificationLibrary/event"
import label "github.com/ModularVerification/ReusableVerificationLibrary/label"
import p "github.com/ModularVerification/ReusableVerificationLibrary/principal"
import tm "github.com/ModularVerification/ReusableVerificationLibrary/term"
import u "github.com/ModularVerification/ReusableVerificationLibrary/usage"

type TraceContext interface {
    pred eventInv(principal p.Principal, ev Event, prev TraceEntry)

    ghost
    // decreases
    /**
     * Specifies consistency conditions for an event. These conditions
     * have to be implied by `pureEventInv`
     */
    pure EventConsistency(ev Event) bool

    ghost
    // decreases
    pure pureEventInv(principal p.Principal, ev Event, prev TraceEntry) bool

    ghost
    decreases
    requires pureEventInv(principal, ev, prev)
    ensures  EventConsistency(ev)
    eventInvImpliesConsistency(principal p.Principal, ev Event, prev TraceEntry)
    
    ghost
    // decreases
    /**
     * expresses whether an event type does only occur once with 
     * certain parameters
     */
    pure IsUnique(typ EventType) bool

    ghost
    // decreases
    requires EventConsistency(ev)
    requires IsUnique(ev.typ)
    /** 
     * returns the witness from which event uniqueness can be derived.
     * This typically is a nonce stored as an event parameter
     */
    pure UniquenessWitness(ev Event) tm.Term

    ghost
    decreases
    requires IsUnique(ev.typ)
    requires eventInv(principal, ev, prev)
    ensures  EventConsistency(ev)
    ensures  nonce == UniquenessWitness(ev)
    ensures  (GetLabeling()).NonceForEventIsUnique(nonce, ev.typ)
    ensures  (GetLabeling()).NonceForEventIsUnique(nonce, ev.typ) --* eventInv(principal, ev, prev)
    isUniqueImpliesUniqueResource(principal p.Principal, ev Event, prev TraceEntry) (nonce tm.Term)


    pred corruptInv(id p.Id, prev TraceEntry)

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires acc(eventInv(principal, ev, prev), p)
    ensures  acc(eventInv(principal, ev, prev), p)
    ensures  pureEventInv(principal, ev, prev)
    getPureEventInv(principal p.Principal, ev Event, prev TraceEntry, p perm)

    ghost
    decreases
    requires t1.isSuffix(t2)
    requires eventInv(principal, ev, t1)
    ensures  eventInv(principal, ev, t2)
    eventInvMonotonic(principal p.Principal, ev Event, t1 TraceEntry, t2 TraceEntry)

    ghost
    decreases
    requires t1.isSuffix(t2)
    requires pureEventInv(principal, ev, t1)
    ensures  pureEventInv(principal, ev, t2)
    pureEventInvMonotonic(principal p.Principal, ev Event, t1 TraceEntry, t2 TraceEntry)

    ghost
    decreases
    requires t1.isSuffix(t2)
    requires corruptInv(id, t1)
    ensures  corruptInv(id, t2)
    corruptInvMonotonic(id p.Id, t1 TraceEntry, t2 TraceEntry)

    ghost
    // decreases
    ensures res != nil
    pure GetLabeling() (res LabelingContext)
}

type LabelingContext interface {
    pred Pred()
    pred NonceIsUnique(nonce tm.Term)
    pred NonceForEventIsUnique(nonce tm.Term, eventType EventType)

    ghost
    decreases
    requires acc(Pred(), _)
    requires acc(NonceForEventIsUnique(nonce, eventType), 2/1)
    ensures  false
    NonceForEventContradiction(nonce tm.Term, eventType EventType)

    ghost
    requires acc(Pred(), _)
    pure IsSecret(t TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage) bool

    ghost
    requires acc(Pred(), _)
    pure IsLabeled(t TraceEntry, term tm.Term, l label.SecrecyLabel) bool

    ghost
    requires acc(Pred(), _)
    pure IsPublishable(t TraceEntry, term tm.Term) bool

    ghost
    pure CanFlow(t TraceEntry, l1, l2 label.SecrecyLabel) bool

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires acc(Pred(), p)
    requires t1.isSuffix(t2)
    requires IsSecret(t1, term, l, usage)
    ensures  acc(Pred(), p)
    ensures  IsSecret(t2, term, l, usage)
    IsSecretMonotonic(t1, t2 TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage, p perm)

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires acc(Pred(), p)
    requires t1.isSuffix(t2)
    requires IsLabeled(t1, term, l)
    ensures  acc(Pred(), p)
    ensures  IsLabeled(t2, term, l)
    IsLabeledMonotonic(t1, t2 TraceEntry, term tm.Term, l label.SecrecyLabel, p perm)

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires acc(Pred(), p)
    requires t1.isSuffix(t2)
    requires IsPublishable(t1, term)
    ensures  acc(Pred(), p)
    ensures  IsPublishable(t2, term)
    IsPublishableMonotonic(t1, t2 TraceEntry, term tm.Term, p perm)

    ghost
    decreases
    ensures  CanFlow(t, l, l)
    CanFlowReflexive(t TraceEntry, l label.SecrecyLabel)

    ghost
    requires acc(Pred(), _)
    pure CanEncrypt(t TraceEntry, msg, pk tm.Term) bool

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires acc(Pred(), p)
    requires CanEncrypt(t, msg, pk) || (IsPublishable(t, msg) && IsPublishable(t, pk))
    ensures  acc(Pred(), p)
    ensures  IsPublishable(t, tm.encrypt(msg, pk))
    CiphertextIsPublishable(t TraceEntry, msg, pk tm.Term, p perm)

    ghost
    requires acc(Pred(), _)
    pure CanDecrypt(t TraceEntry, ciphertext, sk tm.Term, skOwner p.Id) bool

    ghost
    requires acc(Pred(), _)
    pure WasDecrypted(t TraceEntry, msg, sk tm.Term, skOwner p.Id) bool

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires acc(Pred(), p)
    requires IsPublishable(t, ciphertext) && IsPublishable(t, sk)
    ensures  acc(Pred(), p)
    ensures  CanDecrypt(t, ciphertext, sk, skOwner)
    CanDecryptWithPublicSk(t TraceEntry, ciphertext, sk tm.Term, skOwner p.Id, p perm)

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires acc(Pred(), p)
    requires CanDecrypt(t, tm.encrypt(msg, tm.createPk(sk)), sk, skOwner)
    ensures  acc(Pred(), p)
    ensures  WasDecrypted(t, msg, sk, skOwner)
    DecryptSatisfiesInvariant(t TraceEntry, msg, sk tm.Term, skOwner p.Id, p perm)

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires acc(Pred(), p)
    requires IsPublishable(t, tm.encrypt(msg, tm.createPk(sk))) && IsPublishable(t, sk)
    ensures  acc(Pred(), p)
    ensures  IsPublishable(t, msg)
    PlaintextIsPublishableForPublicSk(t TraceEntry, msg, sk tm.Term, skOwner p.Id, p perm)

    ghost
    requires acc(Pred(), _)
    pure CanAeadEncrypt(t TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel) bool

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires acc(Pred(), p)
    requires CanAeadEncrypt(t, key, nonce, msg, ad, keyL) || (IsPublishable(t, key) && IsPublishable(t, nonce) && IsPublishable(t, msg) && IsPublishable(t, ad))
    ensures  acc(Pred(), p)
    ensures  IsPublishable(t, tm.aead(key, nonce, msg, ad))
    AeadCiphertextIsPublishable(t TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel, p perm)

    ghost
    requires acc(Pred(), _)
    pure CanAeadDecrypt(t TraceEntry, key, nonce, ciphertext, ad tm.Term, keyL label.SecrecyLabel) bool

    ghost
    requires acc(Pred(), _)
    pure WasAeadDecrypted(t TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel) bool

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires acc(Pred(), p)
    requires IsPublishable(t, key) && IsPublishable(t, nonce) && IsPublishable(t, ciphertext) && IsPublishable(t, ad)
    ensures  acc(Pred(), p)
    ensures  CanAeadDecrypt(t, key, nonce, ciphertext, ad, keyL)
    CanAeadDecryptWithPublishableKey(t TraceEntry, key, nonce, ciphertext, ad tm.Term, keyL label.SecrecyLabel, p perm)

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires acc(Pred(), p)
    requires CanAeadDecrypt(t, key, nonce, tm.aead(key, nonce, msg, ad), ad, keyL)
    ensures  acc(Pred(), p)
    ensures  WasAeadDecrypted(t, key, nonce, msg, ad, keyL)
    AeadDecryptSatisfiesInvariant(t TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel, p perm)

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires acc(Pred(), p)
    requires IsPublishable(t, tm.aead(key, nonce, msg, ad)) && IsPublishable(t, key) && IsPublishable(t, nonce) && IsPublishable(t, ad)
    ensures  acc(Pred(), p)
    ensures  IsPublishable(t, msg)
    PlaintextIsPublishableForPublishableKey(t TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel, p perm)

    ghost
    decreases
    requires noPerm < p && p <= writePerm
    requires acc(Pred(), p)
    requires IsLabeled(t, term, l)
    requires l.IsReaders()
    requires !containsCorruptId(t.getCorruptIds(), label.GetReaders(l))
    ensures  acc(Pred(), p)
    ensures  !IsPublishable(t, term)
    PublishableRequiresCorruption(t TraceEntry, term tm.Term, l label.SecrecyLabel, p perm)

    // TODO: reduce this interface to the bare minimum (I guess `IsPublishable` & `IsLabeled`) and instead offer
    // a `ApplyMonotonicity` method that can have arbitrary spec for each labeling implementation
}

// because Go & Gobra do not allow receivers of interface type, `ctx` becomes the first argument:
pred validTrace(ctx TraceContext, t TraceEntry) {
    ctx != nil && ctx.GetLabeling().Pred() &&
    // invariant holds recursively:
    (!t.isRoot() ==> validTrace(ctx, getPrev(t))) &&

    (t.isRoot() ==> publicInv(ctx, getPublicTerms(t), t)) &&
    (t.isEvent() ==> ctx.eventInv(getPrincipal(t), getEvent(t), getPrev(t))) &&
    (t.isMessage() ==> messageInv(ctx, getSender(t), getReceiver(t), getPayload(t), getPrev(t))) &&
    (t.isDropMessage() ==> messageInv(ctx, getSender(t), getReceiver(t), getPayload(t), getPrev(t))) &&
    (t.isNonce() ==> randInv(ctx, getNonce(t), getPrev(t))) &&
    (t.isPublic() ==> madePublicInv(ctx, getPayload(t), getPrev(t))) &&
    (t.isCorrupt() ==> ctx.corruptInv(getId(t), getPrev(t)))
}

ghost
requires ctx != nil && acc(ctx.GetLabeling().Pred(), _)
requires t.isRoot()
pure func publicInv(ctx TraceContext, publicTerms set[tm.Term], t TraceEntry) bool {
    return forall publicTerm tm.Term :: { publicTerm in publicTerms } publicTerm in publicTerms ==> ctx.GetLabeling().IsPublishable(t, publicTerm)
}

ghost
requires ctx != nil && acc(ctx.GetLabeling().Pred(), _)
pure func messageInv(ctx TraceContext, sender, receiver p.Principal, payload tm.Term, prev TraceEntry) bool {
    return ctx.GetLabeling().IsPublishable(prev, payload)
}

ghost
decreases
requires ctx != nil
requires noPerm < p && p <= writePerm
requires t1.isSuffix(t2)
requires acc(ctx.GetLabeling().Pred(), p)
requires messageInv(ctx, sender, receiver, payload, t1)
ensures  acc(ctx.GetLabeling().Pred(), p)
ensures  messageInv(ctx, sender, receiver, payload, t2)
func messageInvTransitive(ctx TraceContext, sender, receiver p.Principal, payload tm.Term, t1, t2 TraceEntry, p perm) {
    ctx.GetLabeling().IsPublishableMonotonic(t1, t2, payload, p)
}

pred randInv(ctx TraceContext, nonce tm.Term, prev TraceEntry) {
    ctx != nil &&
    pureRandInv(ctx, nonce, prev) &&
    ctx.GetLabeling().NonceIsUnique(nonce)
}

ghost
pure func pureRandInv(ctx TraceContext, nonce tm.Term, prev TraceEntry) bool {
    return nonce.IsRandom()
}

ghost
requires ctx != nil
requires acc(ctx.GetLabeling().Pred(), _)
pure func madePublicInv(ctx TraceContext, term tm.Term, prev TraceEntry) bool {
    return ctx.GetLabeling().IsPublishable(prev, term)
}

ghost
requires ctx != nil
requires noPerm < p && p <= writePerm
requires acc(ctx.GetLabeling().Pred(), p)
requires t1.isSuffix(t2)
requires madePublicInv(ctx, term, t1)
ensures  acc(ctx.GetLabeling().Pred(), p)
ensures  madePublicInv(ctx, term, t2)
func madePublicInvTransitive(ctx TraceContext, term tm.Term, t1, t2 TraceEntry, p perm) {
    ctx.GetLabeling().IsPublishableMonotonic(t1, t2, term, p)
}
