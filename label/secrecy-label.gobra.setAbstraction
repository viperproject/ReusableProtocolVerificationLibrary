package label

import p "github.com/ModularVerification/ReusableVerificationLibrary/principal"

type SecrecyLabel domain {
    // constructors
    // type 0
    func Public() SecrecyLabel
    // type 1
    func Readers(set[p.Id]) SecrecyLabel
    // type 2
    func Meet(SecrecyLabel, SecrecyLabel) SecrecyLabel // intersection of labels
    // type 3
    func Join(SecrecyLabel, SecrecyLabel) SecrecyLabel // union of labels

    // WARNING: adapt first axiom if another SecrecyLabel is added!

    // deconstructors
    func GetType(SecrecyLabel) int
    func GetReaders(SecrecyLabel) set[p.Id]
    func GetFirstLabel(SecrecyLabel) SecrecyLabel
    func GetSecondLabel(SecrecyLabel) SecrecyLabel

    axiom { // all labels have a type
        forall l SecrecyLabel :: { GetType(l) } 0 <= GetType(l) && GetType(l) <= 3
    }
    
    axiom { // public has type 0
        GetType(Public()) == 0 
    }
    axiom { // public type implies its construction
        forall l SecrecyLabel :: { GetType(l) == 0 } GetType(l) == 0 ==> l == Public()
    }

    axiom { // readers is injective
        forall scopes set[p.Id] :: { Readers(scopes) } GetType(Readers(scopes)) == 1 &&
            GetReaders(Readers(scopes)) == scopes
    }
    axiom { // readers type implies its construction
        forall l SecrecyLabel :: { GetType(l) == 1 } GetType(l) == 1 ==> l == Readers(GetReaders(l))
    }

    axiom { // meet is injective
        forall l1, l2 SecrecyLabel :: { Meet(l1, l2) } GetType(Meet(l1, l2)) == 2 &&
            GetFirstLabel(Meet(l1, l2)) == l1 &&
            GetSecondLabel(Meet(l1, l2)) == l2
    }
    axiom { // meet type implies its construction
        forall l SecrecyLabel :: { GetType(l) == 2 } GetType(l) == 2 ==> l == Meet(GetFirstLabel(l), GetSecondLabel(l))
    }

    axiom { // join is injective
        forall l1, l2 SecrecyLabel :: { Join(l1, l2) } GetType(Join(l1, l2)) == 3 &&
            GetFirstLabel(Join(l1, l2)) == l1 &&
            GetSecondLabel(Join(l1, l2)) == l2
    }
    axiom { // join type implies its construction
        forall l SecrecyLabel :: { GetType(l) == 3 } GetType(l) == 3 ==> l == Join(GetFirstLabel(l), GetSecondLabel(l))
    }
}

ghost
decreases
pure func (label SecrecyLabel) IsPublic() bool {
    return GetType(label) == 0
}

ghost
decreases
pure func (label SecrecyLabel) IsReaders() bool {
    return GetType(label) == 1
}

ghost
decreases
pure func (label SecrecyLabel) IsMeet() bool {
    return GetType(label) == 2
}

ghost
decreases
pure func (label SecrecyLabel) IsJoin() bool {
    return GetType(label) == 3
}

ghost
decreases _ // TODO decreases due to SecrecyLabel ADT
pure func (label SecrecyLabel) GetSet() InfiniteSet {
    return label.IsPublic() ? Infinite() :
        label.IsReaders() ? Finite(GetReaders(label)) :
        label.IsMeet() ? GetFirstLabel(label).GetSet().Intersection(GetSecondLabel(label).GetSet()) :
            GetFirstLabel(label).GetSet().Union(GetSecondLabel(label).GetSet())
        /*
        // label is Meet or Join from now on
        (label.IsMeet() && GetFirstLabel(label).IsPublic()) ? GetSecondLabel(label).GetSet() :
        (label.IsMeet() && GetSecondLabel(label).IsPublic()) ? GetFirstLabel(label).GetSet() :
        label.IsMeet() ? GetFirstLabel(label).GetSet() intersection GetSecondLabel(label).GetSet() :
        (GetFirstLabel(label).IsPublic() || GetSecondLabel(label).IsPublic()) ? 
            GetFirstLabel(label).GetSet() union GetSecondLabel(label).GetSet()
        */
}

type InfiniteSet domain {
    // constructors
    // type 0
    func Infinite() InfiniteSet
    // type 1
    func Finite(set[p.Id]) InfiniteSet

    func GetSetType(InfiniteSet) int
    func GetSet(InfiniteSet) set[p.Id]

    axiom { // all sets have a type
        forall l InfiniteSet :: { GetSetType(l) } 0 <= GetSetType(l) && GetSetType(l) <= 1
    }
    
    axiom { // infinite has type 0
        GetSetType(Infinite()) == 0 
    }
    axiom { // infinite type implies its construction
        forall l InfiniteSet :: { GetSetType(l) == 0 } GetSetType(l) == 0 ==> l == Infinite()
    }

    axiom { // finite is injective
        forall scopes set[p.Id] :: { Finite(scopes) } GetSetType(Finite(scopes)) == 1 &&
            GetSet(Finite(scopes)) == scopes
    }
    axiom { // finite type implies its construction
        forall l InfiniteSet :: { GetSetType(l) == 1 } GetSetType(l) == 1 ==> l == Finite(GetSet(l))
    }
}

ghost
decreases
pure func (s InfiniteSet) IsFinite() bool {
    return GetSetType(s) == 1
}

ghost
decreases
pure func (set1 InfiniteSet) Intersection(set2 InfiniteSet) InfiniteSet {
    return !set1.IsFinite() ? set2 :
        !set2.IsFinite() ? set1 :
            Finite(GetSet(set1) intersection GetSet(set2))
}

ghost
decreases
pure func (set1 InfiniteSet) Union(set2 InfiniteSet) InfiniteSet {
    return set1.IsFinite() && set2.IsFinite() ? Finite(GetSet(set1) union GetSet(set2)) :
        Infinite()
}

ghost
decreases
pure func (set1 InfiniteSet) Subset(set2 InfiniteSet) bool {
    return !set2.IsFinite() ? true :
        !set1.IsFinite() ? false :
            GetSet(set1) subset GetSet(set2)
}
